/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/exceptions.h"
#include "mupdf/fitz.h"
#include "mupdf/internal.h"

#include <iostream>

#include <string.h>

#ifndef NDEBUG
	static const bool   s_trace_exceptions = mupdf::internal_env_flag("MUPDF_trace_exceptions");
#endif

namespace mupdf
{

FZ_FUNCTION FzErrorBase::FzErrorBase(int code, const char* text)
: m_code(code)
{
	char    code_text[32];
	snprintf(code_text, sizeof(code_text), "%i", code);
	m_text = std::string("code=") + code_text + ": " + text;
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorBase: m_code=" << m_code << " m_text: " << m_text << "\n";
	}
	#endif
};

FZ_FUNCTION const char* FzErrorBase::what() const throw()
{
	return m_text.c_str();
};


FZ_FUNCTION FzErrorNone::FzErrorNone(const char* text)
: FzErrorBase(FZ_ERROR_NONE, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorNone constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorMemory::FzErrorMemory(const char* text)
: FzErrorBase(FZ_ERROR_MEMORY, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorMemory constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorGeneric::FzErrorGeneric(const char* text)
: FzErrorBase(FZ_ERROR_GENERIC, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorGeneric constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorSyntax::FzErrorSyntax(const char* text)
: FzErrorBase(FZ_ERROR_SYNTAX, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorSyntax constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorMinor::FzErrorMinor(const char* text)
: FzErrorBase(FZ_ERROR_MINOR, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorMinor constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorTrylater::FzErrorTrylater(const char* text)
: FzErrorBase(FZ_ERROR_TRYLATER, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorTrylater constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorAbort::FzErrorAbort(const char* text)
: FzErrorBase(FZ_ERROR_ABORT, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorAbort constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorRepaired::FzErrorRepaired(const char* text)
: FzErrorBase(FZ_ERROR_REPAIRED, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorRepaired constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION FzErrorCount::FzErrorCount(const char* text)
: FzErrorBase(FZ_ERROR_COUNT, text)
{
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): FzErrorCount constructor, text: " << m_text << "\n";
	}
	#endif
}


FZ_FUNCTION void internal_throw_exception(fz_context* ctx)
{
	int code = fz_caught(ctx);
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): code=" << code << "\n";
	}
	#endif
	const char* text = fz_caught_message(ctx);
	#ifndef NDEBUG
	if (s_trace_exceptions)
	{
		std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): text=" << text << "\n";
	}
	#endif
	if (code == FZ_ERROR_NONE)     throw FzErrorNone    (text);
	if (code == FZ_ERROR_MEMORY)   throw FzErrorMemory  (text);
	if (code == FZ_ERROR_GENERIC)  throw FzErrorGeneric (text);
	if (code == FZ_ERROR_SYNTAX)   throw FzErrorSyntax  (text);
	if (code == FZ_ERROR_MINOR)    throw FzErrorMinor   (text);
	if (code == FZ_ERROR_TRYLATER) throw FzErrorTrylater(text);
	if (code == FZ_ERROR_ABORT)    throw FzErrorAbort   (text);
	if (code == FZ_ERROR_REPAIRED) throw FzErrorRepaired(text);
	if (code == FZ_ERROR_COUNT)    throw FzErrorCount   (text);
	throw FzErrorBase(code, text);
}


} /* End of namespace mupdf. */
