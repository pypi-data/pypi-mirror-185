/**
This file was auto-generated by mupdfwrap.py.
*/


#include "mupdf/exceptions.h"
#include "mupdf/internal.h"

#include <iostream>
#include <thread>
#include <mutex>

#include <string.h>


namespace mupdf
{

FZ_FUNCTION int internal_env_flag(const char* name)
{
	const char* s = getenv( name);
	if (!s) return 0;
	return atoi( s);
}

struct internal_state
{
	/* Constructor. */
	internal_state()
	{
		m_locks.user = this;
		m_locks.lock = lock;
		m_locks.unlock = unlock;
		m_ctx = nullptr;
		bool multithreaded = true;
		const char* s = getenv( "MUPDF_mt_ctx");
		if ( s && !strcmp( s, "0")) multithreaded = false;
		reinit( multithreaded);
	}

	void reinit( bool multithreaded)
	{
		fz_drop_context( m_ctx);
		m_multithreaded = multithreaded;
		m_ctx = fz_new_context(NULL /*alloc*/, (multithreaded) ? &m_locks : nullptr, FZ_STORE_DEFAULT);
		fz_register_document_handlers(m_ctx);
	}
	static void lock(void *user, int lock)
	{
		internal_state*    self = (internal_state*) user;
		assert( self->m_multithreaded);
		self->m_mutexes[lock].lock();
	}
	static void unlock(void *user, int lock)
	{
		internal_state*    self = (internal_state*) user;
		assert( self->m_multithreaded);
		self->m_mutexes[lock].unlock();
	}
	~internal_state()
	{
		fz_drop_context(m_ctx);
	}

	bool                m_multithreaded;
	fz_context*         m_ctx;
	std::mutex          m_mutex;    /* Serialise access to m_ctx. fixme: not actually necessary. */

	/* Provide thread support to mupdf. */
	std::mutex          m_mutexes[FZ_LOCK_MAX];
	fz_locks_context    m_locks;
};

static internal_state  s_state;

struct internal_thread_state
{
	internal_thread_state()
	:
	m_ctx( nullptr),
	m_constructed( true)
	{}
	fz_context* get_context()
	{
		assert( s_state.m_multithreaded);

		/* The following code checks that we are not being called after
		we have been destructed. This can happen if global mupdf
		wrapper class instances are defined - thread-local objects
		are destructed /before/ globals. */
		if (!m_constructed)
		{
			std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << ":\n"
					<< "*** Error - undefined behaviour.\n"
					<< "***\n"
					<< "*** Attempt to get thread-local fz_context after destruction\n"
					<< "*** of thread-local fz_context support instance.\n"
					<< "***\n"
					<< "*** This is undefined behaviour.\n"
					<< "***\n"
					<< "*** This can happen if mupdf wrapper class instances are\n"
					<< "*** created as globals, because in C++ global object\n"
					<< "*** destructors are run after thread_local destructors.\n"
					<< "***\n"
					;
		}
		assert( m_constructed);
		if (!m_ctx)
		{
			/* Make a context for this thread by cloning the global
			context. */
			/* fixme: we don't actually need to take a lock here. */
			std::lock_guard<std::mutex> lock( s_state.m_mutex);
			m_ctx = fz_clone_context(s_state.m_ctx);
		}
		return m_ctx;
	}
	~internal_thread_state()
	{
		if (m_ctx)
		{
			assert( s_state.m_multithreaded);
			fz_drop_context( m_ctx);
		}

		/* These two statements are an attempt to get useful
		diagnostics in cases of undefined behaviour caused by the
		use of global wrapper class instances, whose destructors
		will be called /after/ destruction of this thread-local
		internal_thread_state instance. See check of m_constructed in
		get_context().

		This probably only works in non-optimised builds -
		optimisation will simply elide both these statements. */
		m_ctx = nullptr;
		m_constructed = false;
	}
	fz_context* m_ctx;
	bool m_constructed;
};

static thread_local internal_thread_state  s_thread_state;

FZ_FUNCTION fz_context* internal_context_get()
{
	if (s_state.m_multithreaded)
	{
		return s_thread_state.get_context();
	}
	else
	{
		/* This gives a small improvement in performance for
		single-threaded use, e.g. from 552.4s to 548.1s. */
		return s_state.m_ctx;
	}
}

FZ_FUNCTION void reinit_singlethreaded()
{
	std::cerr << __FILE__ << ":" << __LINE__ << ":" << __FUNCTION__ << "(): Reinitialising as single-threaded.\n";
	s_state.reinit( false /*multithreaded*/);
}

} /* End of namespace mupdf. */
