from typing import Any, ClassVar

from typing import overload
import numpy
import pydrake.autodiffutils
import pydrake.common.cpp_template
import pydrake.common.value
import pydrake.symbolic
AngleAxis_: pydrake.common.cpp_template.TemplateClass
Isometry3_: pydrake.common.cpp_template.TemplateClass
Quaternion_: pydrake.common.cpp_template.TemplateClass

class AngleAxis:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: float, axis: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[float]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> float: ...
    def axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[float]: ...
    def multiply(self, other: AngleAxis_[float]) -> Quaternion_[float]: ...
    def quaternion(self) -> Quaternion_[float]: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_angle(self, angle: float) -> None: ...
    def set_axis(self, axis: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[float]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[float]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[float]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class AngleAxis_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: pydrake.autodiffutils.AutoDiffXd, axis: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[AutoDiffXd]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def axis(self) -> numpy.ndarray[object[3,1]]: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[AutoDiffXd]: ...
    def multiply(self, other: AngleAxis_[AutoDiffXd]) -> Quaternion_[AutoDiffXd]: ...
    def quaternion(self) -> Quaternion_[AutoDiffXd]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_angle(self, angle: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def set_axis(self, axis: numpy.ndarray[object[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[AutoDiffXd]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[AutoDiffXd]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class AngleAxis_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: pydrake.symbolic.Expression, axis: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[Expression]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[Expression]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> pydrake.symbolic.Expression: ...
    def axis(self) -> numpy.ndarray[object[3,1]]: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[Expression]: ...
    def multiply(self, other: AngleAxis_[Expression]) -> Quaternion_[Expression]: ...
    def quaternion(self) -> Quaternion_[Expression]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_angle(self, angle: pydrake.symbolic.Expression) -> None: ...
    def set_axis(self, axis: numpy.ndarray[object[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[Expression]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[Expression]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class AngleAxis_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: float, axis: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[float]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> float: ...
    def axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[float]: ...
    def multiply(self, other: AngleAxis_[float]) -> Quaternion_[float]: ...
    def quaternion(self) -> Quaternion_[float]: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_angle(self, angle: float) -> None: ...
    def set_axis(self, axis: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[float]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[float]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[float]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class Isometry3:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[numpy.float64[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]], translation: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[float]: ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[numpy.float64[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> Isometry3_[float]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[float]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[4,4]]) -> None: ...

class Isometry3_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]], translation: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[AutoDiffXd]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[AutoDiffXd]: ...
    def matrix(self) -> numpy.ndarray[object[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> Isometry3_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[AutoDiffXd]: ...
    def __getstate__(self) -> numpy.ndarray[object[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...

class Isometry3_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]], translation: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[Expression]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[Expression]: ...
    def matrix(self) -> numpy.ndarray[object[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> Isometry3_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[Expression]: ...
    def __getstate__(self) -> numpy.ndarray[object[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...

class Isometry3_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[numpy.float64[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]], translation: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[float]: ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[numpy.float64[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> Isometry3_[float]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[float]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[4,4]]) -> None: ...

class Quaternion:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[numpy.float64[4,1]]) -> None: ...
    @overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[float]: ...
    def inverse(self) -> Quaternion_[float]: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[numpy.float64[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: float, x: float, y: float, z: float) -> None: ...
    def slerp(self, t: float, other: Quaternion_[float]) -> Quaternion_[float]: ...
    def w(self) -> float: ...
    def wxyz(self) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def x(self) -> float: ...
    def xyz(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __copy__(self) -> Quaternion_[float]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[float]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class Quaternion_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def __init__(self, w: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd, y: pydrake.autodiffutils.AutoDiffXd, z: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[AutoDiffXd]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[AutoDiffXd]: ...
    def inverse(self) -> Quaternion_[AutoDiffXd]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd, y: pydrake.autodiffutils.AutoDiffXd, z: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slerp(self, t: float, other: Quaternion_[AutoDiffXd]) -> Quaternion_[AutoDiffXd]: ...
    def w(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def wxyz(self) -> numpy.ndarray[object[4,1]]: ...
    def x(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def xyz(self) -> numpy.ndarray[object[3,1]]: ...
    def y(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def z(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> Quaternion_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[AutoDiffXd]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class Quaternion_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def __init__(self, w: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression, y: pydrake.symbolic.Expression, z: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[Expression]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[Expression]: ...
    def inverse(self) -> Quaternion_[Expression]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression, y: pydrake.symbolic.Expression, z: pydrake.symbolic.Expression) -> None: ...
    def slerp(self, t: float, other: Quaternion_[Expression]) -> Quaternion_[Expression]: ...
    def w(self) -> pydrake.symbolic.Expression: ...
    def wxyz(self) -> numpy.ndarray[object[4,1]]: ...
    def x(self) -> pydrake.symbolic.Expression: ...
    def xyz(self) -> numpy.ndarray[object[3,1]]: ...
    def y(self) -> pydrake.symbolic.Expression: ...
    def z(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> Quaternion_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[Expression]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class Quaternion_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[numpy.float64[4,1]]) -> None: ...
    @overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[float]: ...
    def inverse(self) -> Quaternion_[float]: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[numpy.float64[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: float, x: float, y: float, z: float) -> None: ...
    def slerp(self, t: float, other: Quaternion_[float]) -> Quaternion_[float]: ...
    def w(self) -> float: ...
    def wxyz(self) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def x(self) -> float: ...
    def xyz(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __copy__(self) -> Quaternion_[float]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[float]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class _TemporaryName_N5Eigen10QuaternionIN5drake8symbolic10ExpressionELi0EEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def __init__(self, w: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression, y: pydrake.symbolic.Expression, z: pydrake.symbolic.Expression) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[Expression]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[Expression]: ...
    def inverse(self) -> Quaternion_[Expression]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression, y: pydrake.symbolic.Expression, z: pydrake.symbolic.Expression) -> None: ...
    def slerp(self, t: float, other: Quaternion_[Expression]) -> Quaternion_[Expression]: ...
    def w(self) -> pydrake.symbolic.Expression: ...
    def wxyz(self) -> numpy.ndarray[object[4,1]]: ...
    def x(self) -> pydrake.symbolic.Expression: ...
    def xyz(self) -> numpy.ndarray[object[3,1]]: ...
    def y(self) -> pydrake.symbolic.Expression: ...
    def z(self) -> pydrake.symbolic.Expression: ...
    def __copy__(self) -> Quaternion_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[Expression]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class _TemporaryName_N5Eigen10QuaternionINS_14AutoDiffScalarINS_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEELi0EEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def __init__(self, w: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd, y: pydrake.autodiffutils.AutoDiffXd, z: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[AutoDiffXd]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[AutoDiffXd]: ...
    def inverse(self) -> Quaternion_[AutoDiffXd]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[object[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd, y: pydrake.autodiffutils.AutoDiffXd, z: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slerp(self, t: float, other: Quaternion_[AutoDiffXd]) -> Quaternion_[AutoDiffXd]: ...
    def w(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def wxyz(self) -> numpy.ndarray[object[4,1]]: ...
    def x(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def xyz(self) -> numpy.ndarray[object[3,1]]: ...
    def y(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def z(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def __copy__(self) -> Quaternion_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[AutoDiffXd]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class _TemporaryName_N5Eigen10QuaternionIdLi0EEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, wxyz: numpy.ndarray[numpy.float64[4,1]]) -> None: ...
    @overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def __init__(self, other: Quaternion_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def conjugate(self) -> Quaternion_[float]: ...
    def inverse(self) -> Quaternion_[float]: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def set_wxyz(self, wxyz: numpy.ndarray[numpy.float64[4,1]]) -> None: ...
    @overload
    def set_wxyz(self, w: float, x: float, y: float, z: float) -> None: ...
    def slerp(self, t: float, other: Quaternion_[float]) -> Quaternion_[float]: ...
    def w(self) -> float: ...
    def wxyz(self) -> numpy.ndarray[numpy.float64[4,1]]: ...
    def x(self) -> float: ...
    def xyz(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def y(self) -> float: ...
    def z(self) -> float: ...
    def __copy__(self) -> Quaternion_[float]: ...
    def __deepcopy__(self, arg0: dict) -> Quaternion_[float]: ...
    def __getstate__(self) -> object: ...
    def __setstate__(self, arg0: object) -> None: ...

class _TemporaryName_N5Eigen9AngleAxisIN5drake8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: pydrake.symbolic.Expression, axis: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[Expression]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[Expression]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> pydrake.symbolic.Expression: ...
    def axis(self) -> numpy.ndarray[object[3,1]]: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[Expression]: ...
    def multiply(self, other: AngleAxis_[Expression]) -> Quaternion_[Expression]: ...
    def quaternion(self) -> Quaternion_[Expression]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_angle(self, angle: pydrake.symbolic.Expression) -> None: ...
    def set_axis(self, axis: numpy.ndarray[object[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[Expression]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[Expression]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5Eigen9AngleAxisINS_14AutoDiffScalarINS_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: pydrake.autodiffutils.AutoDiffXd, axis: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[AutoDiffXd]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def axis(self) -> numpy.ndarray[object[3,1]]: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[AutoDiffXd]: ...
    def multiply(self, other: AngleAxis_[AutoDiffXd]) -> Quaternion_[AutoDiffXd]: ...
    def quaternion(self) -> Quaternion_[AutoDiffXd]: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_angle(self, angle: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def set_axis(self, axis: numpy.ndarray[object[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[AutoDiffXd]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[object[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[AutoDiffXd]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5Eigen9AngleAxisIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, angle: float, axis: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, quaternion: Quaternion_[float]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    @overload
    def __init__(self, other: AngleAxis_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def angle(self) -> float: ...
    def axis(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> AngleAxis_[float]: ...
    def multiply(self, other: AngleAxis_[float]) -> Quaternion_[float]: ...
    def quaternion(self) -> Quaternion_[float]: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_angle(self, angle: float) -> None: ...
    def set_axis(self, axis: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_quaternion(self, q: Quaternion_[float]) -> None: ...
    def set_rotation(self, rotation: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def __copy__(self) -> AngleAxis_[float]: ...
    def __deepcopy__(self, arg0: dict) -> AngleAxis_[float]: ...
    def __getstate__(self) -> tuple: ...
    def __matmul__(self, *args, **kwargs) -> Any: ...
    def __setstate__(self, arg0: tuple) -> None: ...

class _TemporaryName_N5Eigen9TransformIN5drake8symbolic10ExpressionELi3ELi1ELi0EEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]], translation: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[Expression]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[Expression]: ...
    def matrix(self) -> numpy.ndarray[object[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> Isometry3_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[Expression]: ...
    def __getstate__(self) -> numpy.ndarray[object[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...

class _TemporaryName_N5Eigen9TransformINS_14AutoDiffScalarINS_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEELi3ELi1ELi0EEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[object[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[object[3,3]], translation: numpy.ndarray[object[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[AutoDiffXd]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[AutoDiffXd]: ...
    def matrix(self) -> numpy.ndarray[object[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[object[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[object[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[object[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[object[3,1]]: ...
    def __copy__(self) -> Isometry3_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[AutoDiffXd]: ...
    def __getstate__(self) -> numpy.ndarray[object[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[object[4,4]]) -> None: ...

class _TemporaryName_N5Eigen9TransformIdLi3ELi1ELi0EEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    multiply: ClassVar[function] = ...
    __matmul__: ClassVar[function] = ...
    cast: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, matrix: numpy.ndarray[numpy.float64[4,4]]) -> None: ...
    @overload
    def __init__(self, rotation: numpy.ndarray[numpy.float64[3,3]], translation: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    @overload
    def __init__(self, other: Isometry3_[float]) -> None: ...
    def Identity(self, *args, **kwargs) -> Any: ...
    def cast[AutoDiffXd](self, *args, **kwargs) -> Any: ...
    def cast[Expression](self, *args, **kwargs) -> Any: ...
    def cast[float](self, *args, **kwargs) -> Any: ...
    def inverse(self) -> Isometry3_[float]: ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def quaternion(self, *args, **kwargs) -> Any: ...
    def rotation(self) -> numpy.ndarray[numpy.float64[3,3]]: ...
    def set_matrix(self, arg0: numpy.ndarray[numpy.float64[4,4]]) -> None: ...
    def set_quaternion(self, *args, **kwargs) -> Any: ...
    def set_rotation(self, arg0: numpy.ndarray[numpy.float64[3,3]]) -> None: ...
    def set_translation(self, arg0: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def translation(self) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def __copy__(self) -> Isometry3_[float]: ...
    def __deepcopy__(self, arg0: dict) -> Isometry3_[float]: ...
    def __getstate__(self) -> numpy.ndarray[numpy.float64[4,4]]: ...
    def __setstate__(self, arg0: numpy.ndarray[numpy.float64[4,4]]) -> None: ...

class _TemporaryName_N5drake5ValueIN5Eigen9TransformINS1_14AutoDiffScalarINS1_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEELi3ELi1ELi0EEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: Isometry3_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> Isometry3_[AutoDiffXd]: ...
    def get_value(self) -> Isometry3_[AutoDiffXd]: ...
    def set_value(self, arg0: Isometry3_[AutoDiffXd]) -> None: ...

class _TemporaryName_N5drake5ValueIN5Eigen9TransformINS_8symbolic10ExpressionELi3ELi1ELi0EEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: Isometry3_[Expression]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> Isometry3_[Expression]: ...
    def get_value(self) -> Isometry3_[Expression]: ...
    def set_value(self, arg0: Isometry3_[Expression]) -> None: ...

class _TemporaryName_N5drake5ValueIN5Eigen9TransformIdLi3ELi1ELi0EEEEE(pydrake.common.value.AbstractValue):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self, arg0: Isometry3_[float]) -> None: ...
    @overload
    def __init__(self, *args, **kwargs) -> Any: ...
    def get_mutable_value(self) -> Isometry3_[float]: ...
    def get_value(self) -> Isometry3_[float]: ...
    def set_value(self, arg0: Isometry3_[float]) -> None: ...
