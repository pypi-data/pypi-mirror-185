from typing import Any, ClassVar, Optional, Tuple

import numpy
import pydrake.math
import pydrake.systems.framework

class DifferentialInverseKinematicsIntegrator(pydrake.systems.framework.LeafSystem_[float]):
    def __init__(self, robot, frame_E, time_step: float, parameters: DifferentialInverseKinematicsParameters, robot_context: pydrake.systems.framework.Context_[float] = ..., log_only_when_result_state_changes: bool = ...) -> None: ...
    def ForwardKinematics(self, context: pydrake.systems.framework.Context_[float]) -> pydrake.math.RigidTransform_[float]: ...
    def SetPositions(self, context: pydrake.systems.framework.Context_[float], positions: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def get_mutable_parameters(self) -> DifferentialInverseKinematicsParameters: ...
    def get_parameters(self) -> DifferentialInverseKinematicsParameters: ...

class DifferentialInverseKinematicsParameters:
    def __init__(self, num_positions: int, num_velocities: int = ...) -> None: ...
    def get_end_effector_angular_speed_limit(self) -> float: ...
    def get_end_effector_translational_velocity_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[3,1]],numpy.ndarray[numpy.float64[3,1]]]]: ...
    def get_end_effector_velocity_flag(self) -> numpy.ndarray[bool[6,1]]: ...
    def get_joint_acceleration_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]]]: ...
    def get_joint_centering_gain(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def get_joint_position_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]]]: ...
    def get_joint_velocity_limits(self) -> Optional[Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]]]: ...
    def get_maximum_scaling_to_report_stuck(self) -> float: ...
    def get_nominal_joint_position(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def get_num_positions(self) -> int: ...
    def get_num_velocities(self) -> int: ...
    def get_time_step(self) -> float: ...
    def set_end_effector_angular_speed_limit(self, speed: float) -> None: ...
    def set_end_effector_translational_velocity_limits(self, lower: numpy.ndarray[numpy.float64[3,1]], upper: numpy.ndarray[numpy.float64[3,1]]) -> None: ...
    def set_end_effector_velocity_flag(self, flag_E: numpy.ndarray[bool[6,1]]) -> None: ...
    def set_joint_acceleration_limits(self, arg0: Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]]) -> None: ...
    def set_joint_centering_gain(self, K: numpy.ndarray[numpy.float64[m,n]]) -> None: ...
    def set_joint_position_limits(self, arg0: Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]]) -> None: ...
    def set_joint_velocity_limits(self, arg0: Tuple[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,1]]]) -> None: ...
    def set_maximum_scaling_to_report_stuck(self, scaling: float) -> None: ...
    def set_nominal_joint_position(self, arg0: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_time_step(self, dt: float) -> None: ...

class DifferentialInverseKinematicsResult:
    joint_velocities: Optional[numpy.ndarray[numpy.float64[m,1]]]
    status: DifferentialInverseKinematicsStatus
    def __init__(self, **kwargs) -> None: ...

class DifferentialInverseKinematicsStatus:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    _pybind11_del_orig: ClassVar[None] = ...
    kNoSolutionFound: ClassVar[DifferentialInverseKinematicsStatus] = ...
    kSolutionFound: ClassVar[DifferentialInverseKinematicsStatus] = ...
    kStuck: ClassVar[DifferentialInverseKinematicsStatus] = ...
    def __init__(self, value: int) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def DoDifferentialInverseKinematics(*args, **kwargs) -> Any: ...
