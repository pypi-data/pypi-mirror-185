from typing import Any, ClassVar, List, Tuple

from typing import overload
import flags
import numpy
import pydrake.autodiffutils
import pydrake.common._module_py
import pydrake.common.cpp_template
import pydrake.common.eigen_geometry
import pydrake.math
import pydrake.polynomial
import pydrake.symbolic
BsplineTrajectory_: pydrake.common.cpp_template.TemplateClass
PathParameterizedTrajectory_: pydrake.common.cpp_template.TemplateClass
PiecewisePolynomial_: pydrake.common.cpp_template.TemplateClass
PiecewisePose_: pydrake.common.cpp_template.TemplateClass
PiecewiseQuaternionSlerp_: pydrake.common.cpp_template.TemplateClass
PiecewiseTrajectory_: pydrake.common.cpp_template.TemplateClass
StackedTrajectory_: pydrake.common.cpp_template.TemplateClass
Trajectory_: pydrake.common.cpp_template.TemplateClass

class BsplineTrajectory(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[float], control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[float], control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[float]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[float]: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[float]: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[float]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[float],List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[float],List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class BsplineTrajectory_[AutoDiffXd](Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[AutoDiffXd]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[AutoDiffXd]: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[AutoDiffXd]: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[AutoDiffXd]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[AutoDiffXd],List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[AutoDiffXd],List[numpy.ndarray[object[m,n]]]]) -> None: ...

class BsplineTrajectory_[Expression](Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[Expression], control_points: List[List[pydrake.symbolic.Expression]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[Expression], control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[Expression]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[Expression]: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.symbolic.Expression]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[Expression]: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[Expression]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[Expression],List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[Expression],List[numpy.ndarray[object[m,n]]]]) -> None: ...

class BsplineTrajectory_[float](Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[float], control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[float], control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[float]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[float]: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[float]: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[float]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[float],List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[float],List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class PathParameterizedTrajectory(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[float], time_scaling: Trajectory_[float]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def path(self) -> Trajectory_[float]: ...
    def time_scaling(self) -> Trajectory_[float]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[float]: ...

class PathParameterizedTrajectory_[AutoDiffXd](Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[AutoDiffXd], time_scaling: Trajectory_[AutoDiffXd]) -> None: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def path(self) -> Trajectory_[AutoDiffXd]: ...
    def time_scaling(self) -> Trajectory_[AutoDiffXd]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[AutoDiffXd]: ...

class PathParameterizedTrajectory_[Expression](Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[Expression], time_scaling: Trajectory_[Expression]) -> None: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def path(self) -> Trajectory_[Expression]: ...
    def time_scaling(self) -> Trajectory_[Expression]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[Expression]: ...

class PathParameterizedTrajectory_[float](Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[float], time_scaling: Trajectory_[float]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def path(self) -> Trajectory_[float]: ...
    def time_scaling(self) -> Trajectory_[float]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[float]: ...

class PiecewisePolynomial(PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[float]], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[float]: ...
    def Clone(self) -> Trajectory_[float]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[float]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[float]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[float]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[float]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[float], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[float]: ...
    def __add__(self, arg0: PiecewisePolynomial_[float]) -> PiecewisePolynomial_[float]: ...
    def __copy__(self) -> PiecewisePolynomial_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[float]: ...

class PiecewisePolynomial_[AutoDiffXd](PiecewiseTrajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[AutoDiffXd]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[AutoDiffXd]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[AutoDiffXd]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[AutoDiffXd]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[AutoDiffXd], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __add__(self, arg0: PiecewisePolynomial_[AutoDiffXd]) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __copy__(self) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[AutoDiffXd]: ...

class PiecewisePolynomial_[Expression](PiecewiseTrajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[Expression]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[Expression]: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[Expression]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.symbolic.Expression) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[Expression]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[Expression]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[Expression]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[Expression], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.symbolic.Expression) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[Expression]: ...
    def __add__(self, arg0: PiecewisePolynomial_[Expression]) -> PiecewisePolynomial_[Expression]: ...
    def __copy__(self) -> PiecewisePolynomial_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[Expression]: ...

class PiecewisePolynomial_[float](PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[float]], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[float]: ...
    def Clone(self) -> Trajectory_[float]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[float]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[float]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[float]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[float]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[float], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[float]: ...
    def __add__(self, arg0: PiecewisePolynomial_[float]) -> PiecewisePolynomial_[float]: ...
    def __copy__(self) -> PiecewisePolynomial_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[float]: ...

class PiecewisePose(PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[float], orientation_trajectory: PiecewiseQuaternionSlerp_[float]) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform_[float]: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[float], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[float]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[float]: ...
    def __copy__(self) -> PiecewisePose_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[float]: ...

class PiecewisePose_[AutoDiffXd](PiecewiseTrajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[AutoDiffXd], orientation_trajectory: PiecewiseQuaternionSlerp_[AutoDiffXd]) -> None: ...
    def GetAcceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def GetVelocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[AutoDiffXd], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[AutoDiffXd]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __copy__(self) -> PiecewisePose_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[AutoDiffXd]: ...

class PiecewisePose_[Expression](PiecewiseTrajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[Expression], orientation_trajectory: PiecewiseQuaternionSlerp_[Expression]) -> None: ...
    def GetAcceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.symbolic.Expression) -> pydrake.math.RigidTransform_[Expression]: ...
    def GetVelocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[Expression], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[Expression]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[Expression]: ...
    def __copy__(self) -> PiecewisePose_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[Expression]: ...

class PiecewisePose_[float](PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[float], orientation_trajectory: PiecewiseQuaternionSlerp_[float]) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform_[float]: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[float], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[float]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[float]: ...
    def __copy__(self) -> PiecewisePose_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[float]: ...

class PiecewiseQuaternionSlerp(PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[float]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_[float]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[float]]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix_[float]) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[float]) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[float]: ...

class PiecewiseQuaternionSlerp_[AutoDiffXd](PiecewiseTrajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_[AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_[AutoDiffXd]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -> None: ...
    def angular_acceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[AutoDiffXd]: ...

class PiecewiseQuaternionSlerp_[Expression](PiecewiseTrajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[Expression]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_[Expression]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[Expression]]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_[Expression]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -> None: ...
    def angular_acceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.symbolic.Expression) -> pydrake.common.eigen_geometry.Quaternion_[Expression]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[Expression]: ...

class PiecewiseQuaternionSlerp_[float](PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[float]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_[float]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[float]]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix_[float]) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[float]) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[float]: ...

class PiecewiseTrajectory(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class PiecewiseTrajectory_[AutoDiffXd](Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def get_segment_times(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def is_time_in_range(self, t: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...

class PiecewiseTrajectory_[Expression](Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.symbolic.Expression) -> int: ...
    def get_segment_times(self) -> List[pydrake.symbolic.Expression]: ...
    def is_time_in_range(self, t: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def start_time(self) -> pydrake.symbolic.Expression: ...

class PiecewiseTrajectory_[float](Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class StackedTrajectory(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[float]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def __copy__(self) -> StackedTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[float]: ...

class StackedTrajectory_[AutoDiffXd](Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[AutoDiffXd]) -> None: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def __copy__(self) -> StackedTrajectory_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[AutoDiffXd]: ...

class StackedTrajectory_[Expression](Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[Expression]) -> None: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def __copy__(self) -> StackedTrajectory_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[Expression]: ...

class StackedTrajectory_[float](Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[float]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def __copy__(self) -> StackedTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[float]: ...

class Trajectory:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[float]: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, arg0: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class Trajectory_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.autodiffutils.AutoDiffXd, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[AutoDiffXd]: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self, t: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.autodiffutils.AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...

class Trajectory_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.symbolic.Expression, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[Expression]: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.symbolic.Expression: ...
    def value(self, t: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.symbolic.Expression]) -> numpy.ndarray[object[m,n]]: ...

class Trajectory_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[float]: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, arg0: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class _TemporaryName_N5drake12trajectories10TrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.autodiffutils.AutoDiffXd, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[AutoDiffXd]: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def value(self, t: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.autodiffutils.AutoDiffXd]) -> numpy.ndarray[object[m,n]]: ...

class _TemporaryName_N5drake12trajectories10TrajectoryINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: pydrake.symbolic.Expression, derivative_order: int = ...) -> numpy.ndarray[object[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[Expression]: ...
    def cols(self) -> int: ...
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> pydrake.symbolic.Expression: ...
    def value(self, t: pydrake.symbolic.Expression) -> numpy.ndarray[object[m,n]]: ...
    def vector_values(self, arg0: List[pydrake.symbolic.Expression]) -> numpy.ndarray[object[m,n]]: ...

class _TemporaryName_N5drake12trajectories10TrajectoryIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self) -> None: ...
    def EvalDerivative(self, t: float, derivative_order: int = ...) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def MakeDerivative(self, derivative_order: int = ...) -> Trajectory_[float]: ...
    def cols(self) -> int: ...
    def end_time(self) -> float: ...
    def has_derivative(self) -> bool: ...
    def rows(self) -> int: ...
    def start_time(self) -> float: ...
    def value(self, t: float) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def vector_values(self, arg0: List[float]) -> numpy.ndarray[numpy.float64[m,n]]: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[AutoDiffXd], orientation_trajectory: PiecewiseQuaternionSlerp_[AutoDiffXd]) -> None: ...
    def GetAcceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.math.RigidTransform_[AutoDiffXd]: ...
    def GetVelocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[AutoDiffXd], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[AutoDiffXd]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __copy__(self) -> PiecewisePose_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[AutoDiffXd]: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[Expression], orientation_trajectory: PiecewiseQuaternionSlerp_[Expression]) -> None: ...
    def GetAcceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def GetPose(self, time: pydrake.symbolic.Expression) -> pydrake.math.RigidTransform_[Expression]: ...
    def GetVelocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[Expression], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[Expression]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[Expression]: ...
    def __copy__(self) -> PiecewisePose_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[Expression]: ...

class _TemporaryName_N5drake12trajectories13PiecewisePoseIdEE(PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, position_trajectory: PiecewisePolynomial_[float], orientation_trajectory: PiecewiseQuaternionSlerp_[float]) -> None: ...
    def GetAcceleration(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def GetPose(self, time: float) -> pydrake.math.RigidTransform_[float]: ...
    def GetVelocity(self, time: float) -> numpy.ndarray[numpy.float64[6,1]]: ...
    def IsApprox(self, other: PiecewisePose_[float], tol: float) -> bool: ...
    def MakeCubicLinearWithEndLinearVelocity(self, *args, **kwargs) -> Any: ...
    def MakeLinear(self, *args, **kwargs) -> Any: ...
    def get_orientation_trajectory(self) -> PiecewiseQuaternionSlerp_[float]: ...
    def get_position_trajectory(self) -> PiecewisePolynomial_[float]: ...
    def __copy__(self) -> PiecewisePose_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePose_[float]: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[AutoDiffXd]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[AutoDiffXd]: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[AutoDiffXd]: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[AutoDiffXd]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[AutoDiffXd],List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[AutoDiffXd],List[numpy.ndarray[object[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[Expression], control_points: List[List[pydrake.symbolic.Expression]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[Expression], control_points: List[numpy.ndarray[object[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[Expression]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[Expression]: ...
    def FinalValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[object[m,n]]: ...
    def InsertKnots(self, additional_knots: List[pydrake.symbolic.Expression]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[Expression]: ...
    def control_points(self) -> List[numpy.ndarray[object[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[Expression]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[Expression],List[numpy.ndarray[object[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[Expression],List[numpy.ndarray[object[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17BsplineTrajectoryIdEE(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[float], control_points: List[List[float]]) -> None: ...
    @overload
    def __init__(self, basis: pydrake.math.BsplineBasis_[float], control_points: List[numpy.ndarray[numpy.float64[m,n]]]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def CopyBlock(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> BsplineTrajectory_[float]: ...
    def CopyHead(self, n: int) -> BsplineTrajectory_[float]: ...
    def FinalValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InitialValue(self) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def InsertKnots(self, additional_knots: List[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[float]: ...
    def control_points(self) -> List[numpy.ndarray[numpy.float64[m,n]]]: ...
    def num_control_points(self) -> int: ...
    def __copy__(self) -> BsplineTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> BsplineTrajectory_[float]: ...
    def __getstate__(self) -> Tuple[pydrake.math.BsplineBasis_[float],List[numpy.ndarray[numpy.float64[m,n]]]]: ...
    def __setstate__(self, arg0: Tuple[pydrake.math.BsplineBasis_[float],List[numpy.ndarray[numpy.float64[m,n]]]]) -> None: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[AutoDiffXd]) -> None: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def __copy__(self) -> StackedTrajectory_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[AutoDiffXd]: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[Expression]) -> None: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def __copy__(self) -> StackedTrajectory_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[Expression]: ...

class _TemporaryName_N5drake12trajectories17StackedTrajectoryIdEE(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, rowwise: bool = ...) -> None: ...
    def Append(self, arg0: Trajectory_[float]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def __copy__(self) -> StackedTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> StackedTrajectory_[float]: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[AutoDiffXd]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.autodiffutils.AutoDiffXd, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[AutoDiffXd]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[AutoDiffXd]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[AutoDiffXd]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[AutoDiffXd], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __add__(self, arg0: PiecewisePolynomial_[AutoDiffXd]) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __copy__(self) -> PiecewisePolynomial_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[AutoDiffXd]: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[Expression]], arg1: List[pydrake.symbolic.Expression]) -> None: ...
    def AppendCubicHermiteSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: pydrake.symbolic.Expression, sample: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[Expression]: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[Expression]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: pydrake.symbolic.Expression) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[Expression]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[Expression]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[Expression]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[Expression], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: pydrake.symbolic.Expression) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[Expression]: ...
    def __add__(self, arg0: PiecewisePolynomial_[Expression]) -> PiecewisePolynomial_[Expression]: ...
    def __copy__(self) -> PiecewisePolynomial_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[Expression]: ...

class _TemporaryName_N5drake12trajectories19PiecewisePolynomialIdEE(PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    @overload
    def __init__(self, arg0: List[numpy.ndarray[object[m,n]]], arg1: List[float]) -> None: ...
    @overload
    def __init__(self, arg0: List[pydrake.polynomial.Polynomial_[float]], arg1: List[float]) -> None: ...
    def AppendCubicHermiteSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def AppendFirstOrderSegment(self, time: float, sample: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> None: ...
    def Block(self, start_row: int, start_col: int, block_rows: int, block_cols: int) -> PiecewisePolynomial_[float]: ...
    def Clone(self) -> Trajectory_[float]: ...
    def ConcatenateInTime(self, other: PiecewisePolynomial_[float]) -> None: ...
    def CubicHermite(self, *args, **kwargs) -> Any: ...
    def CubicShapePreserving(self, *args, **kwargs) -> Any: ...
    def CubicWithContinuousSecondDerivatives(self, *args, **kwargs) -> Any: ...
    def FirstOrderHold(self, *args, **kwargs) -> Any: ...
    def LagrangeInterpolatingPolynomial(self, *args, **kwargs) -> Any: ...
    def RemoveFinalSegment(self) -> None: ...
    def Reshape(self, rows: int, cols: int) -> None: ...
    def ReverseTime(self) -> None: ...
    def ScaleTime(self, scale: float) -> None: ...
    def Transpose(self) -> PiecewisePolynomial_[float]: ...
    def ZeroOrderHold(self, *args, **kwargs) -> Any: ...
    @overload
    def derivative(self, derivative_order: int = ...) -> PiecewisePolynomial_[float]: ...
    @overload
    def derivative(self) -> Any: ...
    def getPolynomial(self, segment_index: int, row: int = ..., col: int = ...) -> pydrake.polynomial.Polynomial_[float]: ...
    def getPolynomialMatrix(self, segment_index: int) -> numpy.ndarray[object[m,n]]: ...
    def getSegmentPolynomialDegree(self, segment_index: int, row: int = ..., col: int = ...) -> int: ...
    def isApprox(self, other: PiecewisePolynomial_[float], tol: float, tol_type: pydrake.common._module_py.ToleranceType = ...) -> bool: ...
    def setPolynomialMatrixBlock(self, replacement: numpy.ndarray[object[m,n]], segment_index: int, row_start: int = ..., col_start: int = ...) -> None: ...
    def shiftRight(self, offset: float) -> None: ...
    def slice(self, start_segment_index: int, num_segments: int) -> PiecewisePolynomial_[float]: ...
    def __add__(self, arg0: PiecewisePolynomial_[float]) -> PiecewisePolynomial_[float]: ...
    def __copy__(self) -> PiecewisePolynomial_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewisePolynomial_[float]: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def end_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.autodiffutils.AutoDiffXd) -> int: ...
    def get_segment_times(self) -> List[pydrake.autodiffutils.AutoDiffXd]: ...
    def is_time_in_range(self, t: pydrake.autodiffutils.AutoDiffXd) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.autodiffutils.AutoDiffXd: ...
    @overload
    def start_time(self) -> pydrake.autodiffutils.AutoDiffXd: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def end_time(self) -> pydrake.symbolic.Expression: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: pydrake.symbolic.Expression) -> int: ...
    def get_segment_times(self) -> List[pydrake.symbolic.Expression]: ...
    def is_time_in_range(self, t: pydrake.symbolic.Expression) -> pydrake.symbolic.Formula: ...
    @overload
    def start_time(self, segment_index: int) -> pydrake.symbolic.Expression: ...
    @overload
    def start_time(self) -> pydrake.symbolic.Expression: ...

class _TemporaryName_N5drake12trajectories19PiecewiseTrajectoryIdEE(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def duration(self, segment_index: int) -> float: ...
    @overload
    def end_time(self, segment_index: int) -> float: ...
    @overload
    def end_time(self) -> float: ...
    def get_number_of_segments(self) -> int: ...
    def get_segment_index(self, t: float) -> int: ...
    def get_segment_times(self) -> List[float]: ...
    def is_time_in_range(self, t: float) -> bool: ...
    @overload
    def start_time(self, segment_index: int) -> float: ...
    @overload
    def start_time(self) -> float: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(PiecewiseTrajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_[AutoDiffXd]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_[AutoDiffXd]) -> None: ...
    @overload
    def Append(self, time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -> None: ...
    def angular_acceleration(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.autodiffutils.AutoDiffXd) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.autodiffutils.AutoDiffXd) -> pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[AutoDiffXd]: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpINS_8symbolic10ExpressionEEE(PiecewiseTrajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[Expression]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_[Expression]]) -> None: ...
    @overload
    def __init__(self, breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[Expression]]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_[Expression]) -> None: ...
    @overload
    def Append(self, time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -> None: ...
    def angular_acceleration(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def angular_velocity(self, time: pydrake.symbolic.Expression) -> numpy.ndarray[object[3,1]]: ...
    def orientation(self, time: pydrake.symbolic.Expression) -> pydrake.common.eigen_geometry.Quaternion_[Expression]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[Expression]: ...

class _TemporaryName_N5drake12trajectories24PiecewiseQuaternionSlerpIdEE(PiecewiseTrajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[float]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3,3]]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_[float]]) -> None: ...
    @overload
    def __init__(self, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[float]]) -> None: ...
    @overload
    def Append(self, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_[float]) -> None: ...
    @overload
    def Append(self, time: float, rotation_matrix: pydrake.math.RotationMatrix_[float]) -> None: ...
    @overload
    def Append(self, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[float]) -> None: ...
    def angular_acceleration(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def angular_velocity(self, time: float) -> numpy.ndarray[numpy.float64[3,1]]: ...
    def orientation(self, time: float) -> pydrake.common.eigen_geometry.Quaternion_[float]: ...
    def __copy__(self) -> PiecewiseQuaternionSlerp_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PiecewiseQuaternionSlerp_[float]: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(Trajectory_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[AutoDiffXd], time_scaling: Trajectory_[AutoDiffXd]) -> None: ...
    def Clone(self) -> Trajectory_[AutoDiffXd]: ...
    def path(self) -> Trajectory_[AutoDiffXd]: ...
    def time_scaling(self) -> Trajectory_[AutoDiffXd]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[AutoDiffXd]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[AutoDiffXd]: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryINS_8symbolic10ExpressionEEE(Trajectory_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[Expression], time_scaling: Trajectory_[Expression]) -> None: ...
    def Clone(self) -> Trajectory_[Expression]: ...
    def path(self) -> Trajectory_[Expression]: ...
    def time_scaling(self) -> Trajectory_[Expression]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[Expression]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[Expression]: ...

class _TemporaryName_N5drake12trajectories27PathParameterizedTrajectoryIdEE(Trajectory_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, path: Trajectory_[float], time_scaling: Trajectory_[float]) -> None: ...
    def Clone(self) -> Trajectory_[float]: ...
    def path(self) -> Trajectory_[float]: ...
    def time_scaling(self) -> Trajectory_[float]: ...
    def __copy__(self) -> PathParameterizedTrajectory_[float]: ...
    def __deepcopy__(self, arg0: dict) -> PathParameterizedTrajectory_[float]: ...
