from typing import Any, Callable, ClassVar, List, Optional, Tuple, Union

from typing import overload
import flags
import numpy
import pydrake.math
import pydrake.multibody.plant
import pydrake.symbolic
import pydrake.systems.analysis
import pydrake.systems.framework
import pydrake.systems.primitives
import pydrake.trajectories

class DynamicProgrammingOptions:
    class PeriodicBoundaryCondition:
        high: float
        low: float
        state_index: int
        def __init__(self, state_index: int, low: float, high: float) -> None: ...
    assume_non_continuous_states_are_fixed: Any
    convergence_tol: float
    discount_factor: float
    input_port_index: Union[pydrake.systems.framework.InputPortSelection,pydrake.systems.framework.InputPortIndex]
    periodic_boundary_conditions: List[DynamicProgrammingOptions.PeriodicBoundaryCondition]
    visualization_callback: Callable[[int,pydrake.math.BarycentricMesh,numpy.ndarray[numpy.float64[1,n]],numpy.ndarray[numpy.float64[m,n]]],None]
    def __init__(self) -> None: ...

class FiniteHorizonLinearQuadraticRegulatorOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    N: Optional[numpy.ndarray[numpy.float64[m,n]]]
    Qf: Optional[numpy.ndarray[numpy.float64[m,n]]]
    input_port_index: Union[pydrake.systems.framework.InputPortSelection,pydrake.systems.framework.InputPortIndex]
    u0: pydrake.trajectories.Trajectory_[float]
    ud: pydrake.trajectories.Trajectory_[float]
    use_square_root_method: bool
    x0: pydrake.trajectories.Trajectory_[float]
    xd: Any
    def __init__(self) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class FiniteHorizonLinearQuadraticRegulatorResult:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def K(self) -> Note: ...
    @property
    def S(self) -> pydrake.trajectories.Trajectory_[float]: ...
    @property
    def k0(self) -> pydrake.trajectories.Trajectory_[float]: ...
    @property
    def s0(self) -> pydrake.trajectories.Trajectory_[float]: ...
    @property
    def sx(self) -> pydrake.trajectories.Trajectory_[float]: ...
    @property
    def u0(self) -> pydrake.trajectories.Trajectory_[float]: ...
    @property
    def x0(self) -> pydrake.trajectories.Trajectory_[float]: ...

class InverseDynamics(pydrake.systems.framework.LeafSystem_[float]):
    class InverseDynamicsMode:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kGravityCompensation: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
        kInverseDynamics: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    kGravityCompensation: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
    kInverseDynamics: ClassVar[InverseDynamics.InverseDynamicsMode] = ...
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], mode: InverseDynamics.InverseDynamicsMode = ...) -> None: ...
    def is_pure_gravity_compensation(self) -> bool: ...

class InverseDynamicsController(pydrake.systems.framework.Diagram_[float]):
    def __init__(self, robot: pydrake.multibody.plant.MultibodyPlant_[float], kp: numpy.ndarray[numpy.float64[m,1]], ki: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]], has_reference_acceleration: bool) -> None: ...
    def get_input_port_desired_acceleration(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_input_port_desired_state(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_multibody_plant_for_control(self) -> pydrake.multibody.plant.MultibodyPlant_[float]: ...
    def get_output_port_control(self) -> pydrake.systems.framework.OutputPort_[float]: ...
    def set_integral_value(self, arg0: pydrake.systems.framework.Context_[float], arg1: numpy.ndarray[numpy.float64[m,1]]) -> None: ...

class JointStiffnessController(pydrake.systems.framework.LeafSystem_[float]):
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], kp: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def get_input_port_desired_state(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_multibody_plant(self) -> pydrake.multibody.plant.MultibodyPlant_[float]: ...
    def get_output_port_generalized_force(self) -> pydrake.systems.framework.OutputPort_[float]: ...

class PeriodicBoundaryCondition:
    high: float
    low: float
    state_index: int
    def __init__(self, state_index: int, low: float, high: float) -> None: ...

class PidControlledSystem(pydrake.systems.framework.Diagram_[float]):
    @overload
    def __init__(self, plant: pydrake.systems.framework.System_[float], kp: float, ki: float, kd: float, state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.systems.framework.System_[float], kp: numpy.ndarray[numpy.float64[m,1]], ki: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]], state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.systems.framework.System_[float], feedback_selector: numpy.ndarray[numpy.float64[m,n]], kp: float, ki: float, kd: float, state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.systems.framework.System_[float], feedback_selector: numpy.ndarray[numpy.float64[m,n]], kp: numpy.ndarray[numpy.float64[m,1]], ki: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]], state_output_port_index: int = ..., plant_input_port_index: int = ...) -> None: ...
    def get_control_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_state_input_port(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_state_output_port(self) -> pydrake.systems.framework.OutputPort_[float]: ...

class PidController(pydrake.systems.framework.LeafSystem_[float]):
    @overload
    def __init__(self, kp: numpy.ndarray[numpy.float64[m,1]], ki: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, state_projection: numpy.ndarray[numpy.float64[m,n]], kp: numpy.ndarray[numpy.float64[m,1]], ki: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    @overload
    def __init__(self, state_projection: numpy.ndarray[numpy.float64[m,n]], output_projection: numpy.ndarray[numpy.float64[m,n]], kp: numpy.ndarray[numpy.float64[m,1]], ki: numpy.ndarray[numpy.float64[m,1]], kd: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def get_Kd_vector(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def get_Ki_vector(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def get_Kp_vector(self) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def get_input_port_desired_state(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_input_port_estimated_state(self) -> pydrake.systems.framework.InputPort_[float]: ...
    def get_output_port_control(self) -> pydrake.systems.framework.OutputPort_[float]: ...

def DiscreteTimeLinearQuadraticRegulator(A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], B: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]) -> Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,n]]]: ...
def FiniteHorizonLinearQuadraticRegulator(system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], t0: float, tf: float, Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], options: FiniteHorizonLinearQuadraticRegulatorOptions = ...) -> FiniteHorizonLinearQuadraticRegulatorResult: ...
def FittedValueIteration(arg0: pydrake.systems.analysis.Simulator_[float], arg1: Callable[[pydrake.systems.framework.Context_[float]],float], arg2: List[Set[float]], arg3: List[Set[float]], arg4: float, arg5: DynamicProgrammingOptions) -> Tuple[pydrake.systems.primitives.BarycentricMeshSystem,numpy.ndarray[numpy.float64[1,n]]]: ...
def LinearProgrammingApproximateDynamicProgramming(arg0: pydrake.systems.analysis.Simulator_[float], arg1: Callable[[pydrake.systems.framework.Context_[float]],float], arg2: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[object[m,1]]],pydrake.symbolic.Expression], arg3: int, arg4: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], arg5: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], arg6: float, arg7: DynamicProgrammingOptions) -> numpy.ndarray[numpy.float64[m,1]]: ...
@overload
def LinearQuadraticRegulator(A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], B: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], N: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous] = ..., F: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous] = ...) -> Tuple[numpy.ndarray[numpy.float64[m,n]],numpy.ndarray[numpy.float64[m,n]]]: ...
@overload
def LinearQuadraticRegulator(system: pydrake.systems.primitives.LinearSystem_[float], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], N: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous] = ...) -> pydrake.systems.primitives.LinearSystem_[float]: ...
@overload
def LinearQuadraticRegulator(system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], N: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous] = ..., input_port_index: int = ...) -> pydrake.systems.primitives.AffineSystem_[float]: ...
def MakeFiniteHorizonLinearQuadraticRegulator(system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], t0: float, tf: float, Q: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], R: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], options: FiniteHorizonLinearQuadraticRegulatorOptions = ...) -> pydrake.systems.framework.System_[float]: ...
