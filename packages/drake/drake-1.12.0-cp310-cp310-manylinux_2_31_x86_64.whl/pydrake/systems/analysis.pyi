from typing import Any, Callable, ClassVar, List

from typing import overload
import numpy
import pydrake.autodiffutils
import pydrake.common._module_py
import pydrake.common.cpp_template
import pydrake.symbolic
import pydrake.systems.framework
import pydrake.trajectories
IntegratorBase_: pydrake.common.cpp_template.TemplateClass
RungeKutta2Integrator_: pydrake.common.cpp_template.TemplateClass
RungeKutta3Integrator_: pydrake.common.cpp_template.TemplateClass
Simulator_: pydrake.common.cpp_template.TemplateClass

class InitializeParams:
    __fields__: ClassVar[tuple] = ...  # read-only
    _pybind11_del_orig: ClassVar[None] = ...
    suppress_initialization_events: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> InitializeParams: ...
    def __deepcopy__(self, arg0: dict) -> InitializeParams: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class IntegratorBase:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> float: ...
    def get_requested_minimum_step_size(self) -> float: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: float) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: float) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class IntegratorBase_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_requested_minimum_step_size(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class IntegratorBase_[Expression]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[Expression]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[Expression]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> pydrake.symbolic.Expression: ...
    def get_requested_minimum_step_size(self) -> pydrake.symbolic.Expression: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: pydrake.symbolic.Expression) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: pydrake.symbolic.Expression) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class IntegratorBase_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> float: ...
    def get_requested_minimum_step_size(self) -> float: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: float) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: float) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class RandomSimulationResult:
    generator_snapshot: pydrake.common._module_py.RandomGenerator
    output: float
    def __init__(self, *args, **kwargs) -> None: ...

class RegionOfAttractionOptions:
    _pybind11_del_orig: ClassVar[None] = ...
    lyapunov_candidate: pydrake.symbolic.Expression
    state_variables: numpy.ndarray[object[m,1]]
    use_implicit_dynamics: bool
    def __init__(self) -> None: ...
    def __del__(self, *args, **kwargs) -> Any: ...

class RungeKutta2Integrator(IntegratorBase_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], max_step_size: float, context: pydrake.systems.framework.Context_[float] = ...) -> None: ...

class RungeKutta2Integrator_[AutoDiffXd](IntegratorBase_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[AutoDiffXd], max_step_size: pydrake.autodiffutils.AutoDiffXd, context: pydrake.systems.framework.Context_[AutoDiffXd] = ...) -> None: ...

class RungeKutta2Integrator_[Expression](IntegratorBase_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[Expression], max_step_size: pydrake.symbolic.Expression, context: pydrake.systems.framework.Context_[Expression] = ...) -> None: ...

class RungeKutta2Integrator_[float](IntegratorBase_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], max_step_size: float, context: pydrake.systems.framework.Context_[float] = ...) -> None: ...

class RungeKutta3Integrator(IntegratorBase_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = ...) -> None: ...

class RungeKutta3Integrator_[AutoDiffXd](IntegratorBase_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd] = ...) -> None: ...

class RungeKutta3Integrator_[float](IntegratorBase_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = ...) -> None: ...

class Simulator:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = ...) -> None: ...
    def AdvancePendingEvents(self) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self, boundary_time: float) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def Initialize(self, params: InitializeParams = ...) -> SimulatorStatus: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    def ResetStatistics(self) -> None: ...
    def clear_monitor(self) -> None: ...
    def get_actual_realtime_rate(self) -> float: ...
    def get_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_integrator(self) -> IntegratorBase_[float]: ...
    def get_monitor(self) -> Callable[[pydrake.systems.framework.Context_[float]],pydrake.systems.framework.EventStatus]: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_mutable_integrator(self) -> IntegratorBase_[float]: ...
    def get_system(self) -> pydrake.systems.framework.System_[float]: ...
    def get_target_realtime_rate(self) -> float: ...
    def has_context(self) -> bool: ...
    def reset_context(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def set_monitor(self, monitor: Callable[[pydrake.systems.framework.Context_[float]],pydrake.systems.framework.EventStatus]) -> None: ...
    def set_publish_at_initialization(self, publish: bool) -> None: ...
    def set_publish_every_time_step(self, publish: bool) -> None: ...
    def set_target_realtime_rate(self, realtime_rate: float) -> None: ...

class SimulatorConfig:
    __fields__: ClassVar[tuple] = ...  # read-only
    accuracy: float
    integration_scheme: str
    max_step_size: float
    publish_every_time_step: bool
    target_realtime_rate: float
    use_error_control: bool
    def __init__(self, **kwargs) -> None: ...
    def __copy__(self) -> SimulatorConfig: ...
    def __deepcopy__(self, arg0: dict) -> SimulatorConfig: ...

class SimulatorStatus:
    class ReturnReason:
        __members__: ClassVar[dict] = ...  # read-only
        __entries: ClassVar[dict] = ...
        _pybind11_del_orig: ClassVar[None] = ...
        kEventHandlerFailed: ClassVar[SimulatorStatus.ReturnReason] = ...
        kReachedBoundaryTime: ClassVar[SimulatorStatus.ReturnReason] = ...
        kReachedTerminationCondition: ClassVar[SimulatorStatus.ReturnReason] = ...
        def __init__(self, value: int) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def FormatMessage(self) -> str: ...
    def IsIdenticalStatus(self, other: SimulatorStatus) -> bool: ...
    def boundary_time(self) -> float: ...
    def message(self) -> str: ...
    def reason(self) -> SimulatorStatus.ReturnReason: ...
    def return_time(self) -> float: ...
    def succeeded(self) -> bool: ...
    def system(self) -> pydrake.systems.framework.SystemBase: ...

class Simulator_[AutoDiffXd]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd] = ...) -> None: ...
    def AdvancePendingEvents(self) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self, boundary_time: pydrake.autodiffutils.AutoDiffXd) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def Initialize(self, params: InitializeParams = ...) -> SimulatorStatus: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    def ResetStatistics(self) -> None: ...
    def clear_monitor(self) -> None: ...
    def get_actual_realtime_rate(self) -> float: ...
    def get_context(self) -> pydrake.systems.framework.Context_[AutoDiffXd]: ...
    def get_integrator(self) -> IntegratorBase_[AutoDiffXd]: ...
    def get_monitor(self) -> Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],pydrake.systems.framework.EventStatus]: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context_[AutoDiffXd]: ...
    def get_mutable_integrator(self) -> IntegratorBase_[AutoDiffXd]: ...
    def get_system(self) -> pydrake.systems.framework.System_[AutoDiffXd]: ...
    def get_target_realtime_rate(self) -> float: ...
    def has_context(self) -> bool: ...
    def reset_context(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def set_monitor(self, monitor: Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],pydrake.systems.framework.EventStatus]) -> None: ...
    def set_publish_at_initialization(self, publish: bool) -> None: ...
    def set_publish_every_time_step(self, publish: bool) -> None: ...
    def set_target_realtime_rate(self, realtime_rate: float) -> None: ...

class Simulator_[float]:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = ...) -> None: ...
    def AdvancePendingEvents(self) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self, boundary_time: float) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def Initialize(self, params: InitializeParams = ...) -> SimulatorStatus: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    def ResetStatistics(self) -> None: ...
    def clear_monitor(self) -> None: ...
    def get_actual_realtime_rate(self) -> float: ...
    def get_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_integrator(self) -> IntegratorBase_[float]: ...
    def get_monitor(self) -> Callable[[pydrake.systems.framework.Context_[float]],pydrake.systems.framework.EventStatus]: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_mutable_integrator(self) -> IntegratorBase_[float]: ...
    def get_system(self) -> pydrake.systems.framework.System_[float]: ...
    def get_target_realtime_rate(self) -> float: ...
    def has_context(self) -> bool: ...
    def reset_context(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def set_monitor(self, monitor: Callable[[pydrake.systems.framework.Context_[float]],pydrake.systems.framework.EventStatus]) -> None: ...
    def set_publish_at_initialization(self, publish: bool) -> None: ...
    def set_publish_every_time_step(self, publish: bool) -> None: ...
    def set_target_realtime_rate(self, realtime_rate: float) -> None: ...

class _TemporaryName_N5drake7systems14IntegratorBaseIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_requested_minimum_step_size(self) -> pydrake.autodiffutils.AutoDiffXd: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: pydrake.autodiffutils.AutoDiffXd) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class _TemporaryName_N5drake7systems14IntegratorBaseINS_8symbolic10ExpressionEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[Expression]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[Expression]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> pydrake.symbolic.Expression: ...
    def get_requested_minimum_step_size(self) -> pydrake.symbolic.Expression: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: pydrake.symbolic.Expression) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: pydrake.symbolic.Expression) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class _TemporaryName_N5drake7systems14IntegratorBaseIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def StartDenseIntegration(self) -> None: ...
    def StopDenseIntegration(self) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def get_dense_output(self) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def get_fixed_step_mode(self) -> bool: ...
    def get_maximum_step_size(self) -> float: ...
    def get_requested_minimum_step_size(self) -> float: ...
    def get_target_accuracy(self) -> float: ...
    def get_throw_on_minimum_step_size_violation(self) -> bool: ...
    def set_fixed_step_mode(self, arg0: bool) -> None: ...
    @overload
    def set_maximum_step_size(self, arg0: float) -> None: ...
    @overload
    def set_maximum_step_size(self) -> Any: ...
    def set_requested_minimum_step_size(self, arg0: float) -> None: ...
    def set_target_accuracy(self, arg0: float) -> None: ...
    def set_throw_on_minimum_step_size_violation(self, arg0: bool) -> None: ...

class _TemporaryName_N5drake7systems21RungeKutta2IntegratorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(IntegratorBase_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[AutoDiffXd], max_step_size: pydrake.autodiffutils.AutoDiffXd, context: pydrake.systems.framework.Context_[AutoDiffXd] = ...) -> None: ...

class _TemporaryName_N5drake7systems21RungeKutta2IntegratorINS_8symbolic10ExpressionEEE(IntegratorBase_[Expression]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[Expression], max_step_size: pydrake.symbolic.Expression, context: pydrake.systems.framework.Context_[Expression] = ...) -> None: ...

class _TemporaryName_N5drake7systems21RungeKutta2IntegratorIdEE(IntegratorBase_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], max_step_size: float, context: pydrake.systems.framework.Context_[float] = ...) -> None: ...

class _TemporaryName_N5drake7systems21RungeKutta3IntegratorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE(IntegratorBase_[AutoDiffXd]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd] = ...) -> None: ...

class _TemporaryName_N5drake7systems21RungeKutta3IntegratorIdEE(IntegratorBase_[float]):
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = ...) -> None: ...

class _TemporaryName_N5drake7systems9SimulatorIN5Eigen14AutoDiffScalarINS2_6MatrixIdLin1ELi1ELi0ELin1ELi1EEEEEEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd] = ...) -> None: ...
    def AdvancePendingEvents(self) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self, boundary_time: pydrake.autodiffutils.AutoDiffXd) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def Initialize(self, params: InitializeParams = ...) -> SimulatorStatus: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    def ResetStatistics(self) -> None: ...
    def clear_monitor(self) -> None: ...
    def get_actual_realtime_rate(self) -> float: ...
    def get_context(self) -> pydrake.systems.framework.Context_[AutoDiffXd]: ...
    def get_integrator(self) -> IntegratorBase_[AutoDiffXd]: ...
    def get_monitor(self) -> Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],pydrake.systems.framework.EventStatus]: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context_[AutoDiffXd]: ...
    def get_mutable_integrator(self) -> IntegratorBase_[AutoDiffXd]: ...
    def get_system(self) -> pydrake.systems.framework.System_[AutoDiffXd]: ...
    def get_target_realtime_rate(self) -> float: ...
    def has_context(self) -> bool: ...
    def reset_context(self, context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def set_monitor(self, monitor: Callable[[pydrake.systems.framework.Context_[AutoDiffXd]],pydrake.systems.framework.EventStatus]) -> None: ...
    def set_publish_at_initialization(self, publish: bool) -> None: ...
    def set_publish_every_time_step(self, publish: bool) -> None: ...
    def set_target_realtime_rate(self, realtime_rate: float) -> None: ...

class _TemporaryName_N5drake7systems9SimulatorIdEE:
    _original_name: ClassVar[str] = ...
    _original_qualname: ClassVar[str] = ...
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float] = ...) -> None: ...
    def AdvancePendingEvents(self) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self, boundary_time: float) -> SimulatorStatus: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def AdvanceTo(self) -> Any: ...
    @overload
    def Initialize(self, params: InitializeParams = ...) -> SimulatorStatus: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    @overload
    def Initialize(self) -> Any: ...
    def ResetStatistics(self) -> None: ...
    def clear_monitor(self) -> None: ...
    def get_actual_realtime_rate(self) -> float: ...
    def get_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_integrator(self) -> IntegratorBase_[float]: ...
    def get_monitor(self) -> Callable[[pydrake.systems.framework.Context_[float]],pydrake.systems.framework.EventStatus]: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_mutable_integrator(self) -> IntegratorBase_[float]: ...
    def get_system(self) -> pydrake.systems.framework.System_[float]: ...
    def get_target_realtime_rate(self) -> float: ...
    def has_context(self) -> bool: ...
    def reset_context(self, context: pydrake.systems.framework.Context_[float]) -> None: ...
    def set_monitor(self, monitor: Callable[[pydrake.systems.framework.Context_[float]],pydrake.systems.framework.EventStatus]) -> None: ...
    def set_publish_at_initialization(self, publish: bool) -> None: ...
    def set_publish_every_time_step(self, publish: bool) -> None: ...
    def set_target_realtime_rate(self, realtime_rate: float) -> None: ...

@overload
def ApplySimulatorConfig(config: SimulatorConfig, simulator: Simulator_[float]) -> None: ...
@overload
def ApplySimulatorConfig(config: SimulatorConfig, simulator: Simulator_[AutoDiffXd]) -> None: ...
@overload
def ExtractSimulatorConfig(simulator: Simulator_[float]) -> SimulatorConfig: ...
@overload
def ExtractSimulatorConfig(simulator: Simulator_[AutoDiffXd]) -> SimulatorConfig: ...
def GetIntegrationSchemes() -> List[str]: ...
def MonteCarloSimulation(*args, **kwargs) -> Any: ...
@overload
def PrintSimulatorStatistics(arg0: Simulator_[float]) -> None: ...
@overload
def PrintSimulatorStatistics(arg0: Simulator_[AutoDiffXd]) -> None: ...
def RandomSimulation(make_simulator: Callable[[pydrake.common._module_py.RandomGenerator],Simulator_[float]], output: Callable[[pydrake.systems.framework.System_[float],pydrake.systems.framework.Context_[float]],float], final_time: float, generator: pydrake.common._module_py.RandomGenerator) -> float: ...
def RegionOfAttraction(system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], options: RegionOfAttractionOptions = ...) -> pydrake.symbolic.Expression: ...
@overload
def ResetIntegratorFromFlags(simulator: Simulator_[float], scheme: str, max_step_size: float) -> IntegratorBase_[float]: ...
@overload
def ResetIntegratorFromFlags(simulator: Simulator_[AutoDiffXd], scheme: str, max_step_size: pydrake.autodiffutils.AutoDiffXd) -> IntegratorBase_[AutoDiffXd]: ...
