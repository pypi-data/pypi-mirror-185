from typing import Any, Callable, ClassVar, List, Optional, Tuple

from typing import overload
import flags
import numpy
import pydrake.common.eigen_geometry
import pydrake.geometry
import pydrake.math
import pydrake.multibody.plant
import pydrake.multibody.tree
import pydrake.solvers
import pydrake.solvers.MixedIntegerRotationConstraintGenerator
import pydrake.systems.framework

class AngleBetweenVectorsConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameA: pydrake.multibody.tree.Frame_[float], a_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], b_B: numpy.ndarray[numpy.float64[3,1]], angle_lower: float, angle_upper: float, plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], a_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], b_B: numpy.ndarray[numpy.float64[3,1]], angle_lower: float, angle_upper: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class AngleBetweenVectorsCost(pydrake.solvers.Cost):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameA: pydrake.multibody.tree.Frame_[float], a_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], b_B: numpy.ndarray[numpy.float64[3,1]], c: float, plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], a_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], b_B: numpy.ndarray[numpy.float64[3,1]], c: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class ComInPolyhedronConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_[float], A: numpy.ndarray[numpy.float64[m,3],flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]], plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], A: numpy.ndarray[numpy.float64[m,3],flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class ComPositionConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_[float], plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instances: Optional[List[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class DistanceConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], geometry_pair: Tuple[pydrake.geometry.GeometryId], plant_context: pydrake.systems.framework.Context_[float], distance_lower: float, distance_upper: float) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], geometry_pair: Tuple[pydrake.geometry.GeometryId], plant_context: pydrake.systems.framework.Context_[AutoDiffXd], distance_lower: float, distance_upper: float) -> None: ...

class GazeTargetConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameA: pydrake.multibody.tree.Frame_[float], p_AS: numpy.ndarray[numpy.float64[3,1]], n_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], p_BT: numpy.ndarray[numpy.float64[3,1]], cone_half_angle: float, plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], p_AS: numpy.ndarray[numpy.float64[3,1]], n_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BT: numpy.ndarray[numpy.float64[3,1]], cone_half_angle: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class GlobalInverseKinematics:
    class Options:
        _pybind11_del_orig: ClassVar[None] = ...
        approach: pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach
        interval_binning: pydrake.solvers.IntervalBinning
        linear_constraint_only: bool
        num_intervals_per_half_axis: int
        def __init__(self) -> None: ...
        def __del__(self, *args, **kwargs) -> Any: ...
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], options: GlobalInverseKinematics.Options = ...) -> None: ...
    def AddPostureCost(self, q_desired: numpy.ndarray[numpy.float64[m,1]], body_position_cost: numpy.ndarray[numpy.float64[m,1]], body_orientation_cost: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def AddWorldOrientationConstraint(self, body_index: pydrake.multibody.tree.BodyIndex, desired_orientation: pydrake.common.eigen_geometry.Quaternion_[float], angle_tol: float) -> pydrake.solvers.Binding[LinearConstraint]: ...
    def AddWorldPositionConstraint(self, body_index: pydrake.multibody.tree.BodyIndex, p_BQ: numpy.ndarray[numpy.float64[3,1]], box_lb_F: numpy.ndarray[numpy.float64[3,1]], box_ub_F: numpy.ndarray[numpy.float64[3,1]], X_WF: pydrake.math.RigidTransform_[float] = ...) -> pydrake.solvers.Binding[LinearConstraint]: ...
    def AddWorldRelativePositionConstraint(self, body_index_B: pydrake.multibody.tree.BodyIndex, p_BQ: numpy.ndarray[numpy.float64[3,1]], body_index_A: pydrake.multibody.tree.BodyIndex, p_AP: numpy.ndarray[numpy.float64[3,1]], box_lb_F: numpy.ndarray[numpy.float64[3,1]], box_ub_F: numpy.ndarray[numpy.float64[3,1]], X_WF: pydrake.math.RigidTransform_[float] = ...) -> pydrake.solvers.Binding[LinearConstraint]: ...
    def ReconstructGeneralizedPositionSolution(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def SetInitialGuess(self, q: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def body_position(self, body_index: pydrake.multibody.tree.BodyIndex) -> numpy.ndarray[object[3,1]]: ...
    def body_rotation_matrix(self, body_index: pydrake.multibody.tree.BodyIndex) -> numpy.ndarray[object[3,3]]: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...

class InverseKinematics:
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], with_joint_limits: bool = ...) -> None: ...
    def AddAngleBetweenVectorsConstraint(self, frameA: pydrake.multibody.tree.Frame_[float], na_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], nb_B: numpy.ndarray[numpy.float64[3,1]], angle_lower: float, angle_upper: float) -> pydrake.solvers.Binding[Constraint]: ...
    def AddAngleBetweenVectorsCost(self, frameA: pydrake.multibody.tree.Frame_[float], na_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], nb_B: numpy.ndarray[numpy.float64[3,1]], c: float) -> pydrake.solvers.Binding[Cost]: ...
    def AddDistanceConstraint(self, geometry_pair: Tuple[pydrake.geometry.GeometryId], distance_lower: float, distance_upper: float) -> pydrake.solvers.Binding[Constraint]: ...
    def AddGazeTargetConstraint(self, frameA: pydrake.multibody.tree.Frame_[float], p_AS: numpy.ndarray[numpy.float64[3,1]], n_A: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], p_BT: numpy.ndarray[numpy.float64[3,1]], cone_half_angle: float) -> pydrake.solvers.Binding[Constraint]: ...
    def AddMinimumDistanceConstraint(self, minimum_distance: float, threshold_distance: float = ...) -> pydrake.solvers.Binding[Constraint]: ...
    def AddOrientationConstraint(self, frameAbar: pydrake.multibody.tree.Frame_[float], R_AbarA: pydrake.math.RotationMatrix_[float], frameBbar: pydrake.multibody.tree.Frame_[float], R_BbarB: pydrake.math.RotationMatrix_[float], theta_bound: float) -> pydrake.solvers.Binding[Constraint]: ...
    def AddOrientationCost(self, frameAbar: pydrake.multibody.tree.Frame_[float], R_AbarA: pydrake.math.RotationMatrix_[float], frameBbar: pydrake.multibody.tree.Frame_[float], R_BbarB: pydrake.math.RotationMatrix_[float], c: float) -> pydrake.solvers.Binding[Cost]: ...
    def AddPointToPointDistanceConstraint(self, frame1: pydrake.multibody.tree.Frame_[float], p_B1P1: numpy.ndarray[numpy.float64[3,1]], frame2: pydrake.multibody.tree.Frame_[float], p_B2P2: numpy.ndarray[numpy.float64[3,1]], distance_lower: float, distance_upper: float) -> pydrake.solvers.Binding[Constraint]: ...
    def AddPolyhedronConstraint(self, frameF: pydrake.multibody.tree.Frame_[float], frameG: pydrake.multibody.tree.Frame_[float], p_GP: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]]) -> pydrake.solvers.Binding[Constraint]: ...
    @overload
    def AddPositionConstraint(self, frameB: pydrake.multibody.tree.Frame_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], frameA: pydrake.multibody.tree.Frame_[float], p_AQ_lower: numpy.ndarray[numpy.float64[3,1]], p_AQ_upper: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.solvers.Binding[Constraint]: ...
    @overload
    def AddPositionConstraint(self, frameB: pydrake.multibody.tree.Frame_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], frameAbar: pydrake.multibody.tree.Frame_[float], X_AbarA: Optional[pydrake.math.RigidTransform_[float]], p_AQ_lower: numpy.ndarray[numpy.float64[3,1]], p_AQ_upper: numpy.ndarray[numpy.float64[3,1]]) -> pydrake.solvers.Binding[Constraint]: ...
    def AddPositionCost(self, frameA: pydrake.multibody.tree.Frame_[float], p_AP: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], C: numpy.ndarray[numpy.float64[3,3],flags.f_contiguous]) -> pydrake.solvers.Binding[Cost]: ...
    def context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_mutable_context(self) -> pydrake.systems.framework.Context_[float]: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def q(self) -> numpy.ndarray[object[m,1]]: ...

class MinimumDistanceConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], minimum_distance: float, plant_context: pydrake.systems.framework.Context_[float], penalty_function: Callable[[float,float,float],None] = ..., influence_distance_offset: float = ...) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], minimum_distance: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd], penalty_function: Callable[[float,float,float],None] = ..., influence_distance_offset: float = ...) -> None: ...

class OrientationConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameAbar: pydrake.multibody.tree.Frame_[float], R_AbarA: pydrake.math.RotationMatrix_[float], frameBbar: pydrake.multibody.tree.Frame_[float], R_BbarB: pydrake.math.RotationMatrix_[float], theta_bound: float, plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameAbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_AbarA: pydrake.math.RotationMatrix_[float], frameBbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_BbarB: pydrake.math.RotationMatrix_[float], theta_bound: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class OrientationCost(pydrake.solvers.Cost):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameAbar: pydrake.multibody.tree.Frame_[float], R_AbarA: pydrake.math.RotationMatrix_[float], frameBbar: pydrake.multibody.tree.Frame_[float], R_BbarB: pydrake.math.RotationMatrix_[float], c: float, plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameAbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_AbarA: pydrake.math.RotationMatrix_[float], frameBbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_BbarB: pydrake.math.RotationMatrix_[float], c: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class PointToPointDistanceConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frame1: pydrake.multibody.tree.Frame_[float], p_B1P1: numpy.ndarray[numpy.float64[3,1]], frame2: pydrake.multibody.tree.Frame_[float], p_B2P2: numpy.ndarray[numpy.float64[3,1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frame1: pydrake.multibody.tree.Frame_[AutoDiffXd], p_B1P1: numpy.ndarray[numpy.float64[3,1]], frame2: pydrake.multibody.tree.Frame_[AutoDiffXd], p_B2P2: numpy.ndarray[numpy.float64[3,1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class PolyhedronConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameF: pydrake.multibody.tree.Frame_[float], frameG: pydrake.multibody.tree.Frame_[float], p_GP: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]], plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameF: pydrake.multibody.tree.Frame_[AutoDiffXd], frameG: pydrake.multibody.tree.Frame_[AutoDiffXd], p_GP: numpy.ndarray[numpy.float64[3,n],flags.f_contiguous], A: numpy.ndarray[numpy.float64[m,n],flags.f_contiguous], b: numpy.ndarray[numpy.float64[m,1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class PositionConstraint(pydrake.solvers.Constraint):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameA: pydrake.multibody.tree.Frame_[float], p_AQ_lower: numpy.ndarray[numpy.float64[3,1]], p_AQ_upper: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameAbar: pydrake.multibody.tree.Frame_[float], X_AbarA: Optional[pydrake.math.RigidTransform_[float]], p_AQ_lower: numpy.ndarray[numpy.float64[3,1]], p_AQ_upper: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], p_AQ_lower: numpy.ndarray[numpy.float64[3,1]], p_AQ_upper: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3,1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameAbar: pydrake.multibody.tree.Frame_[AutoDiffXd], X_AbarA: Optional[pydrake.math.RigidTransform_[float]], p_AQ_lower: numpy.ndarray[numpy.float64[3,1]], p_AQ_upper: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3,1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...
    def UpdateLowerBound(self, new_lb: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def UpdateUpperBound(self, new_ub: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def set_bounds(self, new_lb: numpy.ndarray[numpy.float64[m,1]], new_ub: numpy.ndarray[numpy.float64[m,1]]) -> None: ...

class PositionCost(pydrake.solvers.Cost):
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[float], frameA: pydrake.multibody.tree.Frame_[float], p_AP: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[float], p_BQ: numpy.ndarray[numpy.float64[3,1]], C: numpy.ndarray[numpy.float64[3,3],flags.f_contiguous], plant_context: pydrake.systems.framework.Context_[float]) -> None: ...
    @overload
    def __init__(self, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], p_AP: numpy.ndarray[numpy.float64[3,1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3,1]], C: numpy.ndarray[numpy.float64[3,3],flags.f_contiguous], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -> None: ...

class UnitQuaternionConstraint(pydrake.solvers.Constraint):
    def __init__(self) -> None: ...

@overload
def AddUnitQuaternionConstraintOnPlant(plant: pydrake.multibody.plant.MultibodyPlant_[float], q_vars: numpy.ndarray[object[m,1]], prog: pydrake.solvers.MathematicalProgram) -> None: ...
@overload
def AddUnitQuaternionConstraintOnPlant(plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], q_vars: numpy.ndarray[object[m,1]], prog: pydrake.solvers.MathematicalProgram) -> None: ...
