from typing import Callable, List, Optional, Union

from typing import overload
import flags
import numpy
import pydrake.math
import pydrake.solvers
import pydrake.symbolic
import pydrake.systems.framework
import pydrake.trajectories

class DirectCollocation(MultipleShooting):
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], num_time_samples: int, minimum_timestep: float, maximum_timestep: float, input_port_index: Union[pydrake.systems.framework.InputPortSelection,pydrake.systems.framework.InputPortIndex] = ..., assume_non_continuous_states_are_fixed: bool = ...) -> None: ...

class DirectCollocationConstraint(pydrake.solvers.Constraint):
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], input_port_index: Union[pydrake.systems.framework.InputPortSelection,pydrake.systems.framework.InputPortIndex] = ..., assume_non_continuous_states_are_fixed: bool = ...) -> None: ...

class DirectTranscription(MultipleShooting):
    @overload
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], num_time_samples: int, input_port_index: Union[pydrake.systems.framework.InputPortSelection,pydrake.systems.framework.InputPortIndex] = ...) -> None: ...
    @overload
    def __init__(self, system: pydrake.systems.framework.System_[float], context: pydrake.systems.framework.Context_[float], num_time_samples: int, fixed_timestep: TimeStep, input_port_index: Union[pydrake.systems.framework.InputPortSelection,pydrake.systems.framework.InputPortIndex] = ...) -> None: ...

class KinematicTrajectoryOptimization:
    @overload
    def __init__(self, num_positions: int, num_control_points: int, spline_order: int = ..., duration: float = ...) -> None: ...
    @overload
    def __init__(self, trajectory: pydrake.trajectories.BsplineTrajectory_[float]) -> None: ...
    def AddAccelerationBounds(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def AddDurationConstraint(self, lb: Optional[float], ub: Optional[float]) -> None: ...
    def AddDurationCost(self, weight: float = ...) -> None: ...
    def AddJerkBounds(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def AddPathAccelerationConstraint(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]], s: float) -> None: ...
    def AddPathLengthCost(self, weight: float = ..., use_conic_constraint: bool = ...) -> None: ...
    @overload
    def AddPathPositionConstraint(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]], s: float) -> None: ...
    @overload
    def AddPathPositionConstraint(self, constraint: pydrake.solvers.Constraint, s: float) -> None: ...
    def AddPathVelocityConstraint(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]], s: float) -> None: ...
    def AddPositionBounds(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def AddVelocityBounds(self, lb: numpy.ndarray[numpy.float64[m,1]], ub: numpy.ndarray[numpy.float64[m,1]]) -> None: ...
    def AddVelocityConstraintAtNormalizedTime(self, constraint: pydrake.solvers.Constraint, s: float) -> None: ...
    def ReconstructTrajectory(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.trajectories.BsplineTrajectory_[float]: ...
    def SetInitialGuess(self, trajectory: pydrake.trajectories.BsplineTrajectory_[float]) -> None: ...
    def basis(self) -> pydrake.math.BsplineBasis_[float]: ...
    def control_points(self) -> numpy.ndarray[object[m,n]]: ...
    def duration(self) -> pydrake.symbolic.Variable: ...
    def get_mutable_prog(self) -> pydrake.solvers.MathematicalProgram: ...
    def num_control_points(self) -> int: ...
    def num_positions(self) -> int: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...

class MultipleShooting:
    def __init__(self, *args, **kwargs) -> None: ...
    def AddCompleteTrajectoryCallback(self, callback: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,n],flags.f_contiguous],numpy.ndarray[numpy.float64[m,n],flags.f_contiguous],List[numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]]],None], names: List[str]) -> pydrake.solvers.Binding[VisualizationCallback]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, f: pydrake.symbolic.Formula) -> List[pydrake.solvers.Binding[Constraint]]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, f: numpy.ndarray[object[m,1]]) -> List[pydrake.solvers.Binding[Constraint]]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.BoundingBoxConstraint, vars: numpy.ndarray[object[m,1]]) -> List[pydrake.solvers.Binding[BoundingBoxConstraint]]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.LinearEqualityConstraint, vars: numpy.ndarray[object[m,1]]) -> List[pydrake.solvers.Binding[LinearEqualityConstraint]]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.LinearConstraint, vars: numpy.ndarray[object[m,1]]) -> List[pydrake.solvers.Binding[LinearConstraint]]: ...
    @overload
    def AddConstraintToAllKnotPoints(self, constraint: pydrake.solvers.Constraint, vars: numpy.ndarray[object[m,1]]) -> List[pydrake.solvers.Binding[Constraint]]: ...
    def AddDurationBounds(self, lower_bound: float, upper_bound: float) -> pydrake.solvers.Binding[LinearConstraint]: ...
    def AddEqualTimeIntervalsConstraints(self) -> List[pydrake.solvers.Binding[LinearConstraint]]: ...
    @overload
    def AddFinalCost(self, e: pydrake.symbolic.Expression) -> pydrake.solvers.Binding[Cost]: ...
    @overload
    def AddFinalCost(self, matrix: numpy.ndarray[object[m,n],flags.f_contiguous]) -> pydrake.solvers.Binding[Cost]: ...
    def AddInputTrajectoryCallback(self, callback: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]],None]) -> pydrake.solvers.Binding[VisualizationCallback]: ...
    @overload
    def AddRunningCost(self, g: pydrake.symbolic.Expression) -> None: ...
    @overload
    def AddRunningCost(self, g: numpy.ndarray[object[m,n],flags.f_contiguous]) -> None: ...
    def AddStateTrajectoryCallback(self, callback: Callable[[numpy.ndarray[numpy.float64[m,1]],numpy.ndarray[numpy.float64[m,n],flags.f_contiguous]],None]) -> pydrake.solvers.Binding[VisualizationCallback]: ...
    def AddTimeIntervalBounds(self, lower_bound: float, upper_bound: float) -> pydrake.solvers.Binding[BoundingBoxConstraint]: ...
    def GetInputSamples(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def GetSampleTimes(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,1]]: ...
    def GetSequentialVariableAtIndex(self, name: str, index: int) -> numpy.ndarray[object[m,1]]: ...
    def GetSequentialVariableSamples(self, result: pydrake.solvers.MathematicalProgramResult, name: str) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def GetStateSamples(self, result: pydrake.solvers.MathematicalProgramResult) -> numpy.ndarray[numpy.float64[m,n]]: ...
    def NewSequentialVariable(self, rows: int, name: str) -> numpy.ndarray[object[m,1]]: ...
    def ReconstructInputTrajectory(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def ReconstructStateTrajectory(self, result: pydrake.solvers.MathematicalProgramResult) -> pydrake.trajectories.PiecewisePolynomial_[float]: ...
    def SetInitialTrajectory(self, traj_init_u: pydrake.trajectories.PiecewisePolynomial_[float], traj_init_x: pydrake.trajectories.PiecewisePolynomial_[float]) -> None: ...
    def final_state(self) -> numpy.ndarray[object[m,1]]: ...
    def fixed_timestep(self) -> float: ...
    def initial_state(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def input(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def input(self, index: int) -> numpy.ndarray[object[m,1]]: ...
    def prog(self) -> pydrake.solvers.MathematicalProgram: ...
    @overload
    def state(self) -> numpy.ndarray[object[m,1]]: ...
    @overload
    def state(self, index: int) -> numpy.ndarray[object[m,1]]: ...
    def time(self) -> numpy.ndarray[object[1,1]]: ...
    def timestep(self, index: int) -> numpy.ndarray[object[1,1]]: ...

class TimeStep:
    value: float
    def __init__(self, value: float) -> None: ...

def AddDirectCollocationConstraint(constraint: DirectCollocationConstraint, timestep: numpy.ndarray[object[m,1]], state: numpy.ndarray[object[m,1]], next_state: numpy.ndarray[object[m,1]], input: numpy.ndarray[object[m,1]], next_input: numpy.ndarray[object[m,1]], prog: pydrake.solvers.MathematicalProgram) -> pydrake.solvers.Binding[Constraint]: ...
