<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

        <title>
            
    
    Working with Database Metadata
 &mdash;
    SQLAlchemy 2.0 Documentation

        </title>

        
            <!-- begin iterate through site-imported + sphinx environment css_files -->
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
                <link rel="stylesheet" href="../_static/default.css" type="text/css" />
                <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
                <link rel="stylesheet" href="../_static/docs.css" type="text/css" />
                <link rel="stylesheet" href="../_static/changelog.css" type="text/css" />
                <link rel="stylesheet" href="../_static/sphinx_paramlinks.css" type="text/css" />
            <!-- end iterate through site-imported + sphinx environment css_files -->
        

        

    

    <!-- begin layout.mako headers -->

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
        <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="top" title="SQLAlchemy 2.0 Documentation" href="../index.html" />
        <link rel="up" title="SQLAlchemy Unified Tutorial" href="index.html" />
        <link rel="next" title="Working with Data" href="data.html" />
        <link rel="prev" title="Working with Transactions and the DBAPI" href="dbapi_transactions.html" />
    <!-- end layout.mako headers -->


    </head>
    <body>
        
















<div id="docs-container">





<div id="docs-top-navigation-container" class="body-background">
<div id="docs-header">
    <div id="docs-version-header">
        Release: <span class="version-num">2.0.0rc2</span>


        | Release Date: January 9, 2023

    </div>

    <h1><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h1>

</div>
</div>

<div id="docs-body-container">

    <div id="fixed-sidebar" class="withsidebar">



        <div id="docs-sidebar-popout">
            <h3><a href="../index.html">SQLAlchemy 2.0 Documentation</a></h3>
            <p id="sidebar-topnav">
                <a href="../index.html">Home</a>
            </p>

            <div id="sidebar-search">
                <form class="search" action="../search.html" method="get">
                  <label>
                  Search terms:
                  <input type="text" placeholder="search..." name="q" size="12" />
                  </label>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </div>

        </div>

        <div id="docs-sidebar">

        <div id="sidebar-banner">
            
        </div>

        <div id="docs-sidebar-inner">

        
        <h3>
            <a href="index.html" title="SQLAlchemy Unified Tutorial">SQLAlchemy Unified Tutorial</a>
        </h3>

        <ul>
<li><span class="link-container"><a class="reference external" href="engine.html">Establishing Connectivity - the Engine</a></span></li>
<li><span class="link-container"><a class="reference external" href="dbapi_transactions.html">Working with Transactions and the DBAPI</a></span></li>
<li class="selected"><span class="link-container"><strong>Working with Database Metadata</strong><a class="paramlink headerlink reference internal" href="#">¶</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#setting-up-metadata-with-table-objects">Setting up MetaData with Table objects</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#components-of-table">Components of <code class="docutils literal notranslate"><span class="pre">Table</span></code></a></span><ul>
<li><span class="link-container"><a class="reference external" href="#declaring-simple-constraints">Declaring Simple Constraints</a></span></li>
<li><span class="link-container"><a class="reference external" href="#emitting-ddl-to-the-database">Emitting DDL to the Database</a></span></li>
</ul>
</li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#using-orm-declarative-forms-to-define-table-metadata">Using ORM Declarative Forms to Define Table Metadata</a></span><ul>
<li><span class="link-container"><a class="reference external" href="#establishing-a-declarative-base">Establishing a Declarative Base</a></span></li>
<li><span class="link-container"><a class="reference external" href="#declaring-mapped-classes">Declaring Mapped Classes</a></span></li>
<li><span class="link-container"><a class="reference external" href="#emitting-ddl-to-the-database-from-an-orm-mapping">Emitting DDL to the database from an ORM mapping</a></span></li>
<li><span class="link-container"><a class="reference external" href="#combining-core-table-declarations-with-orm-declarative">Combining Core Table Declarations with ORM Declarative</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="#table-reflection">Table Reflection</a></span></li>
</ul>
</li>
<li><span class="link-container"><a class="reference external" href="data.html">Working with Data</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm_data_manipulation.html">Data Manipulation with the ORM</a></span></li>
<li><span class="link-container"><a class="reference external" href="orm_related_objects.html">Working with Related Objects</a></span></li>
<li><span class="link-container"><a class="reference external" href="further_reading.html">Further Reading</a></span></li>
</ul>



        </div>

        </div>

    </div>

    <div id="narrow-index-nav">
        <form class="search" action="../search.html" method="get">
            <label>
                Search terms:
            <input type="text" placeholder="search..." name="q" size="12" />
            </label>
            <input type="submit" value="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>

        <p>
        <a href="../index.html">Home</a>
        </p>

    </div>


        <div id="docs-narrow-top-navigation">
            <ul>
                <li><b>Previous:</b>
                <a href="dbapi_transactions.html" title="previous chapter">Working with Transactions and the DBAPI</a></li>
                <li><b>Next:</b>
                <a href="data.html" title="next chapter">Working with Data</a></li>

            <li><b>Up:</b> <a href="../index.html">Home</a></li>
                    <ul><li><a href="index.html" title="SQLAlchemy Unified Tutorial">SQLAlchemy Unified Tutorial</a></li>
                </ul>



            <li><b>On this page:</b></li>
            <ul>
<li><a class="reference internal" href="#working-with-database-metadata">Working with Database Metadata</a><ul>
<li><a class="reference internal" href="#setting-up-metadata-with-table-objects">Setting up MetaData with Table objects</a><ul>
<li><a class="reference internal" href="#components-of-table">Components of <code class="docutils literal notranslate"><span class="pre">Table</span></code></a><ul>
<li><a class="reference internal" href="#declaring-simple-constraints">Declaring Simple Constraints</a></li>
<li><a class="reference internal" href="#emitting-ddl-to-the-database">Emitting DDL to the Database</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#using-orm-declarative-forms-to-define-table-metadata">Using ORM Declarative Forms to Define Table Metadata</a><ul>
<li><a class="reference internal" href="#establishing-a-declarative-base">Establishing a Declarative Base</a></li>
<li><a class="reference internal" href="#declaring-mapped-classes">Declaring Mapped Classes</a></li>
<li><a class="reference internal" href="#emitting-ddl-to-the-database-from-an-orm-mapping">Emitting DDL to the database from an ORM mapping</a></li>
<li><a class="reference internal" href="#combining-core-table-declarations-with-orm-declarative">Combining Core Table Declarations with ORM Declarative</a></li>
</ul>
</li>
<li><a class="reference internal" href="#table-reflection">Table Reflection</a></li>
</ul>
</li>
</ul>


            </ul>

        </div>



    <div id="docs-body" role="main" class="withsidebar tutorial-metadata" >
        
<aside class="topic">
<p class="topic-title">SQLAlchemy 1.4 / 2.0 Tutorial</p>
<p>This page is part of the <a class="reference internal" href="index.html"><span class="doc">SQLAlchemy Unified Tutorial</span></a>.</p>
<p>Previous: <a class="reference internal" href="dbapi_transactions.html"><span class="doc">Working with Transactions and the DBAPI</span></a>   |   Next: <a class="reference internal" href="data.html"><span class="doc">Working with Data</span></a></p>
</aside>
<section id="working-with-database-metadata">
<span id="tutorial-working-with-metadata"></span><h1>Working with Database Metadata<a class="headerlink" href="#working-with-database-metadata" title="Permalink to this heading">¶</a></h1>
<p>With engines and SQL execution down, we are ready to begin some Alchemy.
The central element of both SQLAlchemy Core and ORM is the SQL Expression
Language which allows for fluent, composable construction of SQL queries.
The foundation for these queries are Python objects that represent database
concepts like tables and columns.   These objects are known collectively
as <a class="reference internal" href="../glossary.html#term-database-metadata"><span class="xref std std-term">database metadata</span></a>.</p>
<p>The most common foundational objects for database metadata in SQLAlchemy are
known as  <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>, <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, and <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>.
The sections below will illustrate how these objects are used in both a
Core-oriented style as well as an ORM-oriented style.</p>
<div class="orm-header docutils container">
<p><strong>ORM readers, stay with us!</strong></p>
<p>As with other sections, Core users can skip the ORM sections, but ORM users
would best be familiar with these objects from both perspectives.
The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object discussed here is declared in a more indirect
(and also fully Python-typed) way when using the ORM, however there is still
a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object within the ORM’s configuration.</p>
</div>
<section class="core-header orm-dependency" id="setting-up-metadata-with-table-objects">
<span id="tutorial-core-metadata"></span><h2>Setting up MetaData with Table objects<a class="headerlink" href="#setting-up-metadata-with-table-objects" title="Permalink to this heading">¶</a></h2>
<p>When we work with a relational database, the basic data-holding structure
in the database which we query from is known a <strong>table</strong>.
In SQLAlchemy, the database “table” is ultimately represented
by a Python object similarly named <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>.</p>
<p>To start using the SQLAlchemy Expression Language, we will want to have
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects constructed that represent all of the database
tables we are interested in working with. The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> is
constructed programmatically, either directly by using the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> constructor, or indirectly by using ORM Mapped classes
(described later at <a class="reference internal" href="#tutorial-orm-table-metadata"><span class="std std-ref">Using ORM Declarative Forms to Define Table Metadata</span></a>).</p>
<p>Within the construction of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, the individual columns and
constraints within the table themselves may be <strong>declared</strong>, meaning we
explicitly spell out in source code what each column and constraint in the
table looks like, or if working with an existing database there is also the
option to collect this information directly from that database, meaning the
contents of each <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> are <strong>reflected</strong> without us having
to declare all (or any) of it explicitly.</p>
<p>Whichever kind of approach is used, we always start out with a collection
that will be where we place our tables known as the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
object.  This object is essentially a <a class="reference internal" href="../glossary.html#term-facade"><span class="xref std std-term">facade</span></a> around a Python dictionary
that stores a series of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects keyed to their string
name.   Constructing this object looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">MetaData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span> <span class="o">=</span> <span class="n">MetaData</span><span class="p">()</span></pre></div>
</div>
<p>Having a single <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object for an entire application is
the most common case, represented as a module-level variable in a single place
in an application, often in a “models” or “dbschema” type of package. It is
also very common that the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> is accessed via an
ORM-centric registry or base class such as the
<a class="reference internal" href="#tutorial-orm-declarative-base"><span class="std std-ref">Declarative Base</span></a>, so that this same
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> is shared among ORM- and Core-declared
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects.</p>
<p>There can be multiple <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collections as well, however
it’s typically most helpful if a series of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects that
are related to each other belong to a single <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
collection.</p>
<p>Once we have a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object, we can declare some
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects.  This tutorial will start with the classic
SQLAlchemy tutorial model, that of the table <code class="docutils literal notranslate"><span class="pre">user_account</span></code>, which would for
example represent the users of a website, and the table <code class="docutils literal notranslate"><span class="pre">address</span></code>,
representing a list of email addresses associated with rows in the <code class="docutils literal notranslate"><span class="pre">user_account</span></code>
table.   When not using ORM Declarative models at all, we construct
each <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object directly, typically assigning each
to a variable
that will be how we will refer to the table in application code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">Table</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">String</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">user_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;user_account&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">metadata_obj</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;fullname&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<section id="components-of-table">
<h3>Components of <code class="docutils literal notranslate"><span class="pre">Table</span></code><a class="headerlink" href="#components-of-table" title="Permalink to this heading">¶</a></h3>
<p>We can observe that the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> construct looks a lot like
a SQL CREATE TABLE statement; starting with the table name, then listing out
each column, where each column has a name and a datatype.   The objects we
use above are:</p>
<ul>
<li><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> - represents a database table and assigns itself
to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection.</p></li>
<li><p><a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> - represents a column in a database table, and
assigns itself to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object.   The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>
usually includes a string name and a type object.   The collection of
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects in terms of the parent <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
are typically accessed via an associative array located at <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.c" title="sqlalchemy.schema.Table.c"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.c</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span>
<span class="go">Column(&#39;name&#39;, String(length=30), table=&lt;user_account&gt;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">user_table</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&#39;id&#39;, &#39;name&#39;, &#39;fullname&#39;]</span></pre></div>
</div>
</li>
<li><p><a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>, <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> - these classes represent
SQL datatypes and can be passed to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> with or without
necessarily being instantiated.  Above, we want to give a length of “30” to
the “name” column, so we instantiated <code class="docutils literal notranslate"><span class="pre">String(30)</span></code>.  But for “id” and
“fullname” we did not specify these, so we can send the class itself.</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The reference and API documentation for <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>,
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> and <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> is at <a class="reference internal" href="../core/metadata.html"><span class="std std-ref">Describing Databases with MetaData</span></a>.
The reference documentation for datatypes is at <a class="reference internal" href="../core/types.html"><span class="std std-ref">SQL Datatype Objects</span></a>.</p>
</div>
<p>In an upcoming section, we will illustrate one of the fundamental
functions of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> which
is to generate <a class="reference internal" href="../glossary.html#term-DDL"><span class="xref std std-term">DDL</span></a> on a particular database connection.  But first
we will declare a second <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>.</p>
<section id="declaring-simple-constraints">
<h4>Declaring Simple Constraints<a class="headerlink" href="#declaring-simple-constraints" title="Permalink to this heading">¶</a></h4>
<p>The first <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> in the example <code class="docutils literal notranslate"><span class="pre">user_table</span></code> includes the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.primary_key" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.primary_key</span></code></a> parameter which is a shorthand technique
of indicating that this <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> should be part of the primary
key for this table.  The primary key itself is normally declared implicitly
and is represented by the <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint" title="sqlalchemy.schema.PrimaryKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrimaryKeyConstraint</span></code></a> construct,
which we can see on the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.primary_key" title="sqlalchemy.schema.Table.primary_key"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Table.primary_key</span></code></a>
attribute on the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">user_table</span><span class="o">.</span><span class="n">primary_key</span>
<span class="go">PrimaryKeyConstraint(Column(&#39;id&#39;, Integer(), table=&lt;user_account&gt;, primary_key=True, nullable=False))</span></pre></div>
</div>
<p>The constraint that is most typically declared explicitly is the
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> object that corresponds to a database
<a class="reference internal" href="../glossary.html#term-foreign-key-constraint"><span class="xref std std-term">foreign key constraint</span></a>.  When we declare tables that are related to
each other, SQLAlchemy uses the presence of these foreign key constraint
declarations not only so that they are emitted within CREATE statements to
the database, but also to assist in constructing SQL expressions.</p>
<p>A <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint" title="sqlalchemy.schema.ForeignKeyConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKeyConstraint</span></code></a> that involves only a single column
on the target table is typically declared using a column-level shorthand notation
via the <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> object.  Below we declare a second table
<code class="docutils literal notranslate"><span class="pre">address</span></code> that will have a foreign key constraint referring to the <code class="docutils literal notranslate"><span class="pre">user</span></code>
table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">ForeignKey</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">address_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
<span class="gp">... </span>    <span class="s2">&quot;address&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">metadata_obj</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user_account.id&quot;</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Column</span><span class="p">(</span><span class="s2">&quot;email_address&quot;</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
<span class="gp">... </span><span class="p">)</span></pre></div>
</div>
<p>The table above also features a third kind of constraint, which in SQL is the
“NOT NULL” constraint, indicated above using the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column.params.nullable" title="sqlalchemy.schema.Column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Column.nullable</span></code></a>
parameter.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>When using the <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.ForeignKey" title="sqlalchemy.schema.ForeignKey"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForeignKey</span></code></a> object within a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> definition, we can omit the datatype for that
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>; it is automatically inferred from that of the
related column, in the above example the <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> datatype
of the <code class="docutils literal notranslate"><span class="pre">user_account.id</span></code> column.</p>
</div>
<p>In the next section we will emit the completed DDL for the <code class="docutils literal notranslate"><span class="pre">user</span></code> and
<code class="docutils literal notranslate"><span class="pre">address</span></code> table to see the completed result.</p>
</section>
<section id="emitting-ddl-to-the-database">
<span id="tutorial-emitting-ddl"></span><h4>Emitting DDL to the Database<a class="headerlink" href="#emitting-ddl-to-the-database" title="Permalink to this heading">¶</a></h4>
<p>We’ve constructed a an object structure that represents
two database tables in a database, starting at the root <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
object, then into two <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects, each of which hold
onto a collection of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> and <a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Constraint" title="sqlalchemy.schema.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constraint</span></code></a>
objects.   This object structure will be at the center of most operations
we perform with both Core and ORM going forward.</p>
<p>The first useful thing we can do with this structure will be to emit CREATE
TABLE statements, or <a class="reference internal" href="../glossary.html#term-DDL"><span class="xref std std-term">DDL</span></a>, to our SQLite database so that we can insert
and query data from them.   We have already all the tools needed to do so, by
invoking the
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.create_all" title="sqlalchemy.schema.MetaData.create_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.create_all()</span></code></a> method on our <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>,
sending it the <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a> that refers to the target database:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">metadata_obj</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span><span class="w"></span>
<span class="n">PRAGMA</span><span class="w"> </span><span class="n">main</span><span class="p">.</span><span class="n">table_</span><span class="p">...</span><span class="n">info</span><span class="p">(</span><span class="ss">&quot;user_account&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">PRAGMA</span><span class="w"> </span><span class="n">main</span><span class="p">.</span><span class="n">table_</span><span class="p">...</span><span class="n">info</span><span class="p">(</span><span class="ss">&quot;address&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">fullname</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">user_id</span><span class="w"> </span><span class="nb">INTEGER</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">email_address</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">user_account</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">COMMIT</span><span class="w"></span>
</div></pre></div>
</div>
<p>The DDL create process by default includes some SQLite-specific PRAGMA statements
that test for the existence of each table before emitting a CREATE.   The full
series of steps are also included within a BEGIN/COMMIT pair to accommodate
for transactional DDL (SQLite does actually support transactional DDL, however
the <code class="docutils literal notranslate"><span class="pre">sqlite3</span></code> database driver historically runs DDL in “autocommit” mode).</p>
<p>The create process also takes care of emitting CREATE statements in the correct
order; above, the FOREIGN KEY constraint is dependent on the <code class="docutils literal notranslate"><span class="pre">user</span></code> table
existing, so the <code class="docutils literal notranslate"><span class="pre">address</span></code> table is created second.   In more complicated
dependency scenarios the FOREIGN KEY constraints may also be applied to tables
after the fact using ALTER.</p>
<p>The <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> object also features a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.drop_all" title="sqlalchemy.schema.MetaData.drop_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.drop_all()</span></code></a> method that will emit DROP statements in the
reverse order as it would emit CREATE in order to drop schema elements.</p>
<aside class="topic">
<p class="topic-title">Migration tools are usually appropriate</p>
<p>Overall, the CREATE / DROP feature of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> is useful
for test suites, small and/or new applications, and applications that use
short-lived databases.  For management of an application database schema
over the long term however, a schema management tool such as <a class="reference external" href="https://alembic.sqlalchemy.org">Alembic</a>, which builds upon SQLAlchemy, is likely
a better choice, as it can manage and orchestrate the process of
incrementally altering a fixed database schema over time as the design of
the application changes.</p>
</aside>
</section>
</section>
</section>
<section class="orm-header" id="using-orm-declarative-forms-to-define-table-metadata">
<span id="tutorial-orm-table-metadata"></span><h2>Using ORM Declarative Forms to Define Table Metadata<a class="headerlink" href="#using-orm-declarative-forms-to-define-table-metadata" title="Permalink to this heading">¶</a></h2>
<aside class="topic">
<p class="topic-title">Why ORM Declarative?</p>
<p>The previous examples illustrated direct use of the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
object, which underlies how SQLAlchemy ultimately refers to database tables
when constructing SQL expressions. As mentioned, the SQLAlchemy ORM provides
for a facade around the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> declaration process referred
towards as <strong>Declarative Table</strong>.  While Declarative Table is oriented
towards ORM-centric applications, it also may be used for a Core-centric
application where it still can offer several benefits over the raw construction
of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects, including:</p>
<ul class="simple">
<li><p>A more succinct and Pythonic style of setting up column definitions, where
Python types may be used to refer to SQL types</p></li>
<li><p>The resulting construct, referred towards as an “ORM Mapped Class”, can be
used to form SQL expressions that in many cases maintain <span class="target" id="index-0"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> typing
information on a per-column basis</p></li>
<li><p>Allows declaration of table metadata and the ORM mapped class used in
persistence / object loading operations all at once.</p></li>
</ul>
<p>This section will illustrate the same <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> metadata
of the previous section(s) being constructed using Declarative Table.</p>
</aside>
<p>When using the ORM, the process by which we declare <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> metadata
is usually combined with the process of declaring <a class="reference internal" href="../glossary.html#term-mapped"><span class="xref std std-term">mapped</span></a> classes.
The mapped class is any Python class we’d like to create, which will then
have attributes on it that will be linked to the columns in a database table.
While there are a few varieties of how this is achieved, the most common
style is known as
<a class="reference internal" href="../orm/declarative_config.html"><span class="std std-ref">declarative</span></a>, and allows us
to declare our user-defined classes and <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> metadata
at once.</p>
<section id="establishing-a-declarative-base">
<span id="tutorial-orm-declarative-base"></span><h3>Establishing a Declarative Base<a class="headerlink" href="#establishing-a-declarative-base" title="Permalink to this heading">¶</a></h3>
<p>When using the ORM, the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection remains present,
however it itself is associated with an ORM-only construct commonly referred
towards as the <strong>Declarative Base</strong>.   The most expedient way to acquire
a new Declarative Base is to create a new class that subclasses the
SQLAlchemy <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase" title="sqlalchemy.orm.DeclarativeBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeclarativeBase</span></code></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">DeclarativeBase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>Above, the <code class="docutils literal notranslate"><span class="pre">Base</span></code> class is what we’ll refer towards as the Declarative Base.
When we make new classes that are subclasses of <code class="docutils literal notranslate"><span class="pre">Base</span></code>, combined with
appropriate class-level directives, they will each be established as part of an
object relational mapping against a particular database table (or tables, in
advanced usages).</p>
<p>The Declarative Base, when declared as a new class, refers to a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection that is
created for us automatically (options exist to use our own <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
object as well); this <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> is accessible via the <code class="docutils literal notranslate"><span class="pre">.metadata</span></code>
class-level attribute.  As we create new mapped classes, they each will reference a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> within this <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span>
<span class="go">MetaData()</span></pre></div>
</div>
<p>The Declarative Base also refers to a collection called <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a>, which
is the central “mapper configuration” unit in the SQLAlchemy ORM.  While
seldom accessed directly, this object is central to the mapper configuration
process, as a set of ORM mapped classes will coordinate with each other via
this registry.   As was the case with <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>, our Declarative
Base also created a <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a> for us (again with options to
pass our own <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a>), which we can access
via the <code class="docutils literal notranslate"><span class="pre">.registry</span></code> class variable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Base</span><span class="o">.</span><span class="n">registry</span>
<span class="go">&lt;sqlalchemy.orm.decl_api.registry object at 0x...&gt;</span></pre></div>
</div>
<p><a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.registry" title="sqlalchemy.orm.registry"><code class="xref py py-class docutils literal notranslate"><span class="pre">registry</span></code></a> also provides other mapper configurational patterns,
including different ways to acquire a Declarative Base object, as well as class
decorators and class-processing functions which allow user-defined classes to
be mapped without using any particular base class. Therefore, keep in mind that
all the ORM patterns here that use “declarative base” can just as easily
use other patterns based on class decorators or configurational functions.</p>
</section>
<section id="declaring-mapped-classes">
<span id="tutorial-declaring-mapped-classes"></span><h3>Declaring Mapped Classes<a class="headerlink" href="#declaring-mapped-classes" title="Permalink to this heading">¶</a></h3>
<p>With the <code class="docutils literal notranslate"><span class="pre">Base</span></code> class established, we can now define ORM mapped classes
for the <code class="docutils literal notranslate"><span class="pre">user_account</span></code> and <code class="docutils literal notranslate"><span class="pre">address</span></code> tables in terms of new classes <code class="docutils literal notranslate"><span class="pre">User</span></code> and
<code class="docutils literal notranslate"><span class="pre">Address</span></code>.  We illustrate below the most modern form of Declarative, which
is driven from <span class="target" id="index-1"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> type annotations using a special type
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a>, which indicates attributes to be mapped as particular
types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">Mapped</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">mapped_column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sqlalchemy.orm</span> <span class="kn">import</span> <span class="n">relationship</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">fullname</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">str</span><span class="p">]]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;User(id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">!r}</span><span class="s2">, name=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, fullname=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="si">!r}</span><span class="s2">)&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;address&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">id</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">email_address</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">str</span><span class="p">]</span>
<span class="gp">... </span>    <span class="n">user_id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;user_account.id&quot;</span><span class="p">))</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">User</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">str</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Address(id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">!r}</span><span class="s2">, email_address=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">email_address</span><span class="si">!r}</span><span class="s2">)&quot;</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>The two classes above, <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code>, are now referred towards
as <strong>ORM Mapped Classes</strong>, and are available for use in
ORM persistence and query operations, which will be described later.  Details
about these classes include:</p>
<ul>
<li><p>Each class refers to a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object that was generated as
part of the declarative mapping process, and are equivalent
in structure to the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects we constructed
directly in the previous Core section.   This <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
is available from an attribute added to the class called <code class="docutils literal notranslate"><span class="pre">__table__</span></code>.</p></li>
<li><p>To indicate columns in the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>, we use the
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> construct, in combination with
typing annotations based on the <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> type.</p></li>
<li><p>For columns with simple datatypes and no other options, we can indicate a
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> type annotation alone, using simple Python types like
<code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">str</span></code> to mean <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> and <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a>.
Customization of how Python types are interpreted within the Declarative
mapping process is very open ended; see the section
<a class="reference internal" href="../orm/declarative_tables.html#orm-declarative-mapped-column"><span class="std std-ref">Using Annotated Declarative Table (Type Annotated Forms for mapped_column())</span></a> for background.</p></li>
<li><p>A column can be declared as “nullable” or “not null” based on the
presence of the <code class="docutils literal notranslate"><span class="pre">Optional[]</span></code> type annotation; alternatively, the
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable" title="sqlalchemy.orm.mapped_column"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">mapped_column.nullable</span></code></a> parameter may be used instead.</p></li>
<li><p>Usage of explicit typing annotations is <strong>completely
optional</strong>.  We can also use <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> without annotations.
When using this form, we would use more explicit type objects like
<a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.Integer" title="sqlalchemy.types.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> and <a class="reference internal" href="../core/type_basics.html#sqlalchemy.types.String" title="sqlalchemy.types.String"><code class="xref py py-class docutils literal notranslate"><span class="pre">String</span></code></a> as well as <code class="docutils literal notranslate"><span class="pre">nullable=False</span></code>
as needed within each <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> construct.</p></li>
<li><p>Two additional attributes, <code class="docutils literal notranslate"><span class="pre">User.addresses</span></code> and <code class="docutils literal notranslate"><span class="pre">Address.user</span></code>, define
a different kind of attribute called <a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a>, which
features similar annotation-aware configuration styles as shown.  The
<a class="reference internal" href="../orm/relationship_api.html#sqlalchemy.orm.relationship" title="sqlalchemy.orm.relationship"><code class="xref py py-func docutils literal notranslate"><span class="pre">relationship()</span></code></a> construct is discussed more fully at
<a class="reference internal" href="orm_related_objects.html#tutorial-orm-related-objects"><span class="std std-ref">Working with Related Objects</span></a>.</p></li>
<li><p>The classes are automatically given an <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method if we don’t
declare one of our own.  The default form of this method accepts all
attribute names as optional keyword arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sandy</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;sandy&quot;</span><span class="p">,</span> <span class="n">fullname</span><span class="o">=</span><span class="s2">&quot;Sandy Cheeks&quot;</span><span class="p">)</span></pre></div>
</div>
</li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">__repr__()</span></code> methods are added so that we get a readable string output;
there’s no requirement for these methods to be here.</p></li>
</ul>
<aside class="topic">
<p class="topic-title">Where’d the old Declarative go?</p>
<p>Users of SQLAlchemy 1.4 or previous will note that the above mapping
uses a dramatically different form than before; not only does it use
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> instead of <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> in the Declarative
mapping, it also uses Python type annotations to derive column information.</p>
<p>To provide context for users of the “old” way, Declarative mappings can
still be made using <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects (as well as using the
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.declarative_base" title="sqlalchemy.orm.declarative_base"><code class="xref py py-func docutils literal notranslate"><span class="pre">declarative_base()</span></code></a> function to create the base class) as before,
and these forms will continue to be supported with no plans to
remove support.  The reason these two facilities
are superseded by new constructs is first and foremost to integrate
smoothly with <span class="target" id="index-2"></span><a class="pep reference external" href="https://peps.python.org/pep-0484/"><strong>PEP 484</strong></a> tools, including IDEs such as VSCode and type
checkers such as Mypy and Pyright, without the need for plugins. Secondly,
deriving the declarations from type annotations is part of SQLAlchemy’s
integration with Python dataclasses, which can now be
<a class="reference internal" href="../orm/dataclasses.html#orm-declarative-native-dataclasses"><span class="std std-ref">generated natively</span></a> from mappings.</p>
<p>For users who like the “old” way, but still desire their IDEs to not
mistakenly report typing errors for their declarative mappings, the
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> construct is a drop-in replacement for
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> in an ORM Declarative mapping (note that
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> is for ORM Declarative mappings only; it can’t
be used within a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> construct), and the type annotations are
optional. Our mapping above can be written without annotations as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__tablename__</span> <span class="o">=</span> <span class="s2">&quot;user_account&quot;</span>

    <span class="n">id</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">Integer</span><span class="p">,</span> <span class="n">primary_key</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span> <span class="n">nullable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">fullname</span> <span class="o">=</span> <span class="n">mapped_column</span><span class="p">(</span><span class="n">String</span><span class="p">)</span>

    <span class="n">addresses</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="s2">&quot;Address&quot;</span><span class="p">,</span> <span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>

    <span class="c1"># ... definition continues</span></pre><div class="code-non-annotations-key"></div></div>
</div>
<p>The above class has an advantage over one that uses <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>
directly, in that the <code class="docutils literal notranslate"><span class="pre">User</span></code> class as well as instances of <code class="docutils literal notranslate"><span class="pre">User</span></code>
will indicate the correct typing information to typing tools, without
the use of plugins.  <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> also allows for additional
ORM-specific parameters to configure behaviors such as deferred column loading,
which previously needed a separate <a class="reference internal" href="../orm/queryguide/columns.html#sqlalchemy.orm.deferred" title="sqlalchemy.orm.deferred"><code class="xref py py-func docutils literal notranslate"><span class="pre">deferred()</span></code></a> function to be
used with <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a>.</p>
<p>There’s also an example of converting an old-style Declarative class
to the new style, which can be seen at <a class="reference internal" href="../changelog/whatsnew_20.html#whatsnew-20-orm-declarative-typing"><span class="std std-ref">ORM Declarative Models</span></a>
in the <a class="reference internal" href="../changelog/whatsnew_20.html"><span class="std std-ref">What’s New in SQLAlchemy 2.0?</span></a> guide.</p>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../orm/mapping_styles.html#orm-mapping-styles"><span class="std std-ref">ORM Mapping Styles</span></a> - full background on different ORM configurational
styles.</p>
<p><a class="reference internal" href="../orm/mapping_styles.html#orm-declarative-mapping"><span class="std std-ref">Declarative Mapping</span></a> - overview of Declarative class mapping</p>
<p><a class="reference internal" href="../orm/declarative_tables.html#orm-declarative-table"><span class="std std-ref">Declarative Table with mapped_column()</span></a> - detail on how to use
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> and <a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> to define the columns
within a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> to be mapped when using Declarative.</p>
</div>
</section>
<section id="emitting-ddl-to-the-database-from-an-orm-mapping">
<h3>Emitting DDL to the database from an ORM mapping<a class="headerlink" href="#emitting-ddl-to-the-database-from-an-orm-mapping" title="Permalink to this heading">¶</a></h3>
<p>As our ORM mapped classes refer to <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects contained
within a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection, emitting DDL given the
Declarative Base uses the same process as that described previously at
<a class="reference internal" href="#tutorial-emitting-ddl"><span class="std std-ref">Emitting DDL to the Database</span></a>. In our case, we have already generated the
<code class="docutils literal notranslate"><span class="pre">user</span></code> and <code class="docutils literal notranslate"><span class="pre">address</span></code> tables in our SQLite database. If we had not done so
already, we would be free to make use of the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a>
associated with our ORM Declarative Base class in order to do so, by accessing
the collection from the <code class="docutils literal notranslate"><span class="pre">Base.metadata</span></code> attribute and then using
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData.create_all" title="sqlalchemy.schema.MetaData.create_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MetaData.create_all()</span></code></a> as before:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Base</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">(</span><span class="n">engine</span><span class="p">)</span></pre></div>
</div>
</section>
<section id="combining-core-table-declarations-with-orm-declarative">
<h3>Combining Core Table Declarations with ORM Declarative<a class="headerlink" href="#combining-core-table-declarations-with-orm-declarative" title="Permalink to this heading">¶</a></h3>
<p>As an alternative approach to the mapping process shown previously
at <a class="reference internal" href="#tutorial-declaring-mapped-classes"><span class="std std-ref">Declaring Mapped Classes</span></a>, we may also make
use of the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects we created directly in the section
<a class="reference internal" href="#tutorial-core-metadata"><span class="std std-ref">Setting up MetaData with Table objects</span></a> in conjunction with
declarative mapped classes from a Declarative Base
class.</p>
<p>This form is called
<a class="reference internal" href="../orm/declarative_tables.html#orm-imperative-table-configuration"><span class="std std-ref">Declarative with Imperative Table</span></a>,
and it consists of assigning a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object to the
<code class="docutils literal notranslate"><span class="pre">.__table__</span></code> attribute directly, rather than having the declarative process
generate it from the <code class="docutils literal notranslate"><span class="pre">.__tablename__</span></code> attribute with separate
<a class="reference internal" href="../orm/internals.html#sqlalchemy.orm.Mapped" title="sqlalchemy.orm.Mapped"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mapped</span></code></a> and/or <a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a> directives. This is
illustrated below by using our pre-existing <code class="docutils literal notranslate"><span class="pre">user_table</span></code> and
<code class="docutils literal notranslate"><span class="pre">address_table</span></code> <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects to map them to new classes
(<strong>note to readers running code</strong>: these examples are for illustration only
and should not be run):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">DeclarativeBase</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">user_table</span>

    <span class="n">addresses</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="s2">&quot;Address&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;user&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;User(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fullname</span><span class="si">!r}</span><span class="s2">)&quot;</span>


<span class="k">class</span> <span class="nc">Address</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
    <span class="n">__table__</span> <span class="o">=</span> <span class="n">address_table</span>

    <span class="n">user</span><span class="p">:</span> <span class="n">Mapped</span><span class="p">[</span><span class="s2">&quot;User&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relationship</span><span class="p">(</span><span class="n">back_populates</span><span class="o">=</span><span class="s2">&quot;addresses&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Address(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">email_address</span><span class="si">!r}</span><span class="s2">)&quot;</span></pre><div class="code-annotations-key"></div></div>
</div>
<p>The above two classes, <code class="docutils literal notranslate"><span class="pre">User</span></code> and <code class="docutils literal notranslate"><span class="pre">Address</span></code>, are equivalent to those which
we declared in the previous mapping example using <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> and
<a class="reference internal" href="../orm/mapping_api.html#sqlalchemy.orm.mapped_column" title="sqlalchemy.orm.mapped_column"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapped_column()</span></code></a>.</p>
<p>The traditional “declarative base” approach using <code class="docutils literal notranslate"><span class="pre">__tablename__</span></code> to
automatically generate <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects remains the most popular
method to declare table metadata.  However, disregarding the ORM mapping
functionality it achieves, as far as table declaration it’s merely a syntactical
convenience on top of the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> constructor.</p>
<p>We will next refer to our ORM mapped classes above when we talk about data
manipulation in terms of the ORM, in the section <a class="reference internal" href="orm_data_manipulation.html#tutorial-inserting-orm"><span class="std std-ref">Inserting Rows using the ORM Unit of Work pattern</span></a>.</p>
</section>
</section>
<section class="core-header" id="table-reflection">
<span id="tutorial-table-reflection"></span><h2>Table Reflection<a class="headerlink" href="#table-reflection" title="Permalink to this heading">¶</a></h2>
<p>To round out the section on working with table metadata, we will illustrate
another operation that was mentioned at the beginning of the section,
that of <strong>table reflection</strong>.   Table reflection refers to the process of
generating <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> and related objects by reading the current
state of a database.   Whereas in the previous sections we’ve been declaring
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> objects in Python and then emitting DDL to the database,
the reflection process does it in reverse.</p>
<p>As an example of reflection, we will create a new <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a>
object which represents the <code class="docutils literal notranslate"><span class="pre">some_table</span></code> object we created manually in
the earlier sections of this document.  There are again some varieties of
how this is performed, however the most basic is to construct a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> object, given the name of the table and a
<a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.MetaData" title="sqlalchemy.schema.MetaData"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetaData</span></code></a> collection to which it will belong, then
instead of indicating individual <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> and
<a class="reference internal" href="../core/constraints.html#sqlalchemy.schema.Constraint" title="sqlalchemy.schema.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">Constraint</span></code></a> objects, pass it the target <a class="reference internal" href="../core/connections.html#sqlalchemy.engine.Engine" title="sqlalchemy.engine.Engine"><code class="xref py py-class docutils literal notranslate"><span class="pre">Engine</span></code></a>
using the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with" title="sqlalchemy.schema.Table"><code class="xref py py-paramref docutils literal notranslate"><span class="pre">Table.autoload_with</span></code></a> parameter:</p>
<div class="highlight-pycon+sql notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;some_table&quot;</span><span class="p">,</span> <span class="n">metadata_obj</span><span class="p">,</span> <span class="n">autoload_with</span><span class="o">=</span><span class="n">engine</span><span class="p">)</span>
<div class='show_sql'><span class="k">BEGIN</span><span class="w"> </span><span class="p">(</span><span class="k">implicit</span><span class="p">)</span><span class="w"></span>
<span class="n">PRAGMA</span><span class="w"> </span><span class="n">main</span><span class="p">.</span><span class="n">table_</span><span class="p">...</span><span class="n">info</span><span class="p">(</span><span class="ss">&quot;some_table&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="n">raw</span><span class="w"> </span><span class="k">sql</span><span class="p">]</span><span class="w"> </span><span class="p">()</span><span class="w"></span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">sql</span><span class="w"> </span><span class="k">FROM</span><span class="w">  </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">sqlite_master</span><span class="w"> </span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w">   </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">sqlite_temp_master</span><span class="p">)</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;table&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;view&#39;</span><span class="p">)</span><span class="w"></span>
<span class="p">[</span><span class="n">raw</span><span class="w"> </span><span class="k">sql</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;some_table&#39;</span><span class="p">,)</span><span class="w"></span>
<span class="n">PRAGMA</span><span class="w"> </span><span class="n">main</span><span class="p">.</span><span class="n">foreign_key_list</span><span class="p">(</span><span class="ss">&quot;some_table&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="n">PRAGMA</span><span class="w"> </span><span class="n">main</span><span class="p">.</span><span class="n">index_list</span><span class="p">(</span><span class="ss">&quot;some_table&quot;</span><span class="p">)</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">ROLLBACK</span><span class="w"></span>
</div></pre></div>
</div>
<p>At the end of the process, the <code class="docutils literal notranslate"><span class="pre">some_table</span></code> object now contains the
information about the <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Column" title="sqlalchemy.schema.Column"><code class="xref py py-class docutils literal notranslate"><span class="pre">Column</span></code></a> objects present in the table, and
the object is usable in exactly the same way as a <a class="reference internal" href="../core/metadata.html#sqlalchemy.schema.Table" title="sqlalchemy.schema.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">Table</span></code></a> that
we declared explicitly:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">some_table</span>
<span class="go">Table(&#39;some_table&#39;, MetaData(),</span>
<span class="go">    Column(&#39;x&#39;, INTEGER(), table=&lt;some_table&gt;),</span>
<span class="go">    Column(&#39;y&#39;, INTEGER(), table=&lt;some_table&gt;),</span>
<span class="go">    schema=None)</span></pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Read more about table and schema reflection at <a class="reference internal" href="../core/reflection.html"><span class="std std-ref">Reflecting Database Objects</span></a>.</p>
<p>For ORM-related variants of table reflection, the section
<a class="reference internal" href="../orm/declarative_tables.html#orm-declarative-reflected"><span class="std std-ref">Mapping Declaratively with Reflected Tables</span></a> includes an overview of the available
options.</p>
</div>
</section>
</section>
<aside class="topic">
<p class="topic-title">SQLAlchemy 1.4 / 2.0 Tutorial</p>
<p>Next Tutorial Section: <a class="reference internal" href="data.html"><span class="doc">Working with Data</span></a></p>
</aside>

    </div>

</div>

<div id="docs-bottom-navigation" class="docs-navigation-links, withsidebar">
        Previous:
        <a href="dbapi_transactions.html" title="previous chapter">Working with Transactions and the DBAPI</a>
        Next:
        <a href="data.html" title="next chapter">Working with Data</a>

    <div id="docs-copyright">
        &copy; <a href="../copyright.html">Copyright</a> 2007-2023, the SQLAlchemy authors and contributors.


    <p><b>flambé!</b> the dragon and <b><i>The Alchemist</i></b> image designs created and generously donated by <a href="https://github.com/vmalloc">Rotem Yaari</a>.</p>

        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 5.3.0.

    Documentation last generated: Mon 09 Jan 2023 03:24:13 PM 

    </div>
</div>

</div>



        
        

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '2.0.0rc2',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>

    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>

    <!-- begin iterate through sphinx environment script_files -->
        <script type="text/javascript" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/sphinx_highlight.js"></script>
        <script type="text/javascript" src="../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    <!-- end iterate through sphinx environment script_files -->

    <script type="text/javascript" src="../_static/init.js"></script>


    </body>
</html>


