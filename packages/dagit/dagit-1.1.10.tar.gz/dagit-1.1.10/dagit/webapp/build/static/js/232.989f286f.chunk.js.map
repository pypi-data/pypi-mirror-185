{"version":3,"file":"static/js/232.989f286f.chunk.js","mappings":"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","sources":["../../core/src/hooks/useDocumentTitle.tsx","../../core/src/hooks/useQueryPersistedState.tsx","../../core/src/pipelines/PipelineReference.tsx","../../core/src/runs/RunStatuses.tsx","../../core/src/runs/RunsFilterInput.tsx","../../ui/src/components/NonIdealState.tsx","../../ui/src/components/TokenizingField.tsx"],"sourcesContent":["import * as React from 'react';\n\nexport const useDocumentTitle = (title: string) => {\n  React.useEffect(() => {\n    const currentTitle = document.title;\n    document.title = title;\n    return () => {\n      document.title = currentTitle;\n    };\n  }, [title]);\n};\n","import isEqual from 'lodash/isEqual';\nimport qs from 'qs';\nimport React from 'react';\nimport {useHistory, useLocation} from 'react-router-dom';\n\ntype QueryPersistedDataType =\n  | {[key: string]: any}\n  | Array<any>\n  | (string | undefined | number)\n  | (boolean | undefined)\n  | null;\n\nlet currentQueryString: {[key: string]: any} = {};\n\nexport type QueryPersistedStateConfig<T extends QueryPersistedDataType> = {\n  queryKey?: string;\n  defaults?: {[key: string]: any};\n  decode?: (raw: {[key: string]: any}) => T;\n  encode?: (raw: T) => {[key: string]: any};\n};\n\n/**\n * This goal of this hook is to make it easy to replace `React.useState` with a version\n * that persists the value to the page querystring so it is saved across page reload, etc.\n * Hopefully by making it easy, we'll do this often and improve overall UX.\n *\n * Examples:\n *\n * // Single (string | undefined) key saved to querystring with default value applied inline\n *\n * const [search = '', setSearch] = useQueryPersistedState({queryKey: 'q'})\n *\n * // Object saved to querystring with default values pre-filled\n * // Note: String and boolean values are automatically encoded / decoded, see below for others\n *\n * const [query, setQuery] = useQueryPersistedState<{cursor: string, filter: string}>({\n *   defaults: {cursor: '', filter: ''},\n * })\n *\n * // Custom transformer mapping to / from querystring representation (for our filter tokens)\n * // Note: `setIdeas` will be a different function on every render unless you memoize the options\n * // passed to the hook! Pull the encode/decode functions out into a file constant or use React.useRef\n *\n * const [ideas, setIdeas] = useQueryPersistedState<string[]>({\n *   encode: (ideas) => ({q: ideas.join(',')}),\n *   decode: ({q}) => (q || '').split(','),\n * })\n *\n * Note: if you combine encode/decode with defaults, the defaults are applied to the query\n * string BEFORE decoding.\n */\nexport function useQueryPersistedState<T extends QueryPersistedDataType>(\n  options: QueryPersistedStateConfig<T>,\n): [T, (updates: T) => void] {\n  const {queryKey, defaults} = options;\n  let {encode, decode} = options;\n\n  if (queryKey) {\n    // Just a short-hand way of providing encode/decode that go from qs object => string\n    if (!encode) {\n      encode = (raw: T) => ({[queryKey]: raw});\n    }\n    if (!decode) {\n      decode = (qs: {[key: string]: any}) => inferTypeOfQueryParam<T>(qs[queryKey]);\n    }\n  }\n\n  const location = useLocation();\n  const history = useHistory();\n\n  // We stash the query string into a ref so that the setter can operate on the /current/\n  // location even if the user retains it and calls it after other query string changes.\n  currentQueryString = qs.parse(location.search, {ignoreQueryPrefix: true});\n\n  const qsWithDefaults = {...(defaults || {}), ...currentQueryString};\n\n  // Note: If you have provided defaults and no encoder/decoder, the `value` exposed by\n  // useQueryPersistedState only includes those keys so other params don't leak into your value.\n  const qsDecoded = decode ? decode(qsWithDefaults) : inferTypeOfQueryParams<T>(qsWithDefaults);\n\n  // If `decode` yields a non-primitive type (eg: object or array), by default we yield\n  // an object with a new identity on every render. To prevent possible render loops caused by\n  // our value as a useEffect dependency, etc., we re-use the last yielded object if it isEqual.\n  const valueRef = React.useRef<T>(qsDecoded);\n  const onChangeRef = React.useCallback<(updated: T) => void>(\n    (updated: T) => {\n      const next = {\n        ...currentQueryString,\n        ...(encode ? encode(updated) : (updated as {[key: string]: any})),\n      };\n\n      // omit any keys that are equal to the defaults to keep URLs minimal\n      for (const [key, value] of Object.entries(next)) {\n        if (options.defaults && options.defaults[key] === value) {\n          delete next[key];\n        }\n      }\n\n      currentQueryString = next;\n      history.replace(`${location.pathname}?${qs.stringify(next, {arrayFormat: 'brackets'})}`);\n    },\n    [history, encode, location.pathname, options],\n  );\n\n  if (!isEqual(valueRef.current, qsDecoded)) {\n    valueRef.current = qsDecoded;\n  }\n  return [valueRef.current, onChangeRef];\n}\n\nfunction inferTypeOfQueryParam<T>(q: any): T {\n  return q === 'false' ? false : q === 'true' ? true : q;\n}\n\nfunction inferTypeOfQueryParams<T>(qs: {[key: string]: any}) {\n  const result: {[key: string]: any} = {};\n  for (const key of Object.keys(qs)) {\n    result[key] = inferTypeOfQueryParam<any>(qs[key]);\n  }\n  return result as T;\n}\n","import {Box, Colors, Icon} from '@dagster-io/ui';\nimport * as React from 'react';\nimport {Link} from 'react-router-dom';\n\nimport {RepoAddress} from '../workspace/types';\nimport {workspacePipelinePath, workspacePipelinePathGuessRepo} from '../workspace/workspacePath';\n\nimport {PipelineSnapshotLink} from './PipelinePathUtils';\n\nexport interface Props {\n  pipelineName: string;\n  pipelineHrefContext: 'repo-unknown' | RepoAddress | 'no-link';\n  isJob: boolean;\n  snapshotId?: string | null;\n  showIcon?: boolean;\n  truncationThreshold?: number;\n  size?: 'small' | 'normal';\n}\n\nconst DEFAULT_TRUNCATION_THRESHOLD = 40;\nconst TRUNCATION_BUFFER = 5;\n\nexport const PipelineReference: React.FC<Props> = ({\n  pipelineName,\n  pipelineHrefContext,\n  isJob,\n  snapshotId,\n  showIcon,\n  truncationThreshold = DEFAULT_TRUNCATION_THRESHOLD,\n  size = 'normal',\n}) => {\n  const truncatedName =\n    truncationThreshold > 0 && pipelineName.length > truncationThreshold\n      ? `${pipelineName.slice(0, truncationThreshold - TRUNCATION_BUFFER)}…`\n      : pipelineName;\n\n  const pipeline =\n    pipelineHrefContext === 'repo-unknown' ? (\n      <Link to={workspacePipelinePathGuessRepo(pipelineName, isJob)}>{truncatedName}</Link>\n    ) : pipelineHrefContext === 'no-link' ? (\n      <>{truncatedName}</>\n    ) : (\n      <Link\n        to={workspacePipelinePath({\n          repoName: pipelineHrefContext.name,\n          repoLocation: pipelineHrefContext.location,\n          pipelineName,\n          isJob,\n        })}\n      >\n        {truncatedName}\n      </Link>\n    );\n\n  return (\n    <Box flex={{direction: 'row', alignItems: 'center', display: 'inline-flex'}}>\n      {showIcon && (\n        <Box margin={{right: 8}}>\n          <Icon color={Colors.Gray400} name=\"job\" />\n        </Box>\n      )}\n      <span>\n        {pipeline}\n        {snapshotId && ' @ '}\n        {snapshotId && (\n          <PipelineSnapshotLink snapshotId={snapshotId} pipelineName={pipelineName} size={size} />\n        )}\n      </span>\n    </Box>\n  );\n};\n","import {RunStatus} from '../graphql/graphql';\n\nexport const queuedStatuses = new Set([RunStatus.QUEUED]);\n\nexport const inProgressStatuses = new Set([\n  RunStatus.STARTED,\n  RunStatus.STARTING,\n  RunStatus.CANCELING,\n]);\n\nexport const successStatuses = new Set([RunStatus.SUCCESS]);\nexport const failedStatuses = new Set([RunStatus.FAILURE, RunStatus.CANCELED]);\nexport const canceledStatuses = new Set([RunStatus.CANCELING, RunStatus.CANCELED]);\n\nexport const doneStatuses = new Set([RunStatus.FAILURE, RunStatus.SUCCESS, RunStatus.CANCELED]);\n\nexport const cancelableStatuses = new Set([RunStatus.QUEUED, RunStatus.STARTED]);\n","import {\n  SuggestionProvider,\n  TokenizingField,\n  TokenizingFieldValue,\n  tokensAsStringArray,\n  tokenizedValuesFromStringArray,\n} from '@dagster-io/ui';\nimport qs from 'qs';\nimport * as React from 'react';\n\nimport {RunStatus, RunsFilter} from '../graphql/graphql';\nimport {useQueryPersistedState} from '../hooks/useQueryPersistedState';\nimport {DagsterRepoOption, useRepositoryOptions} from '../workspace/WorkspaceContext';\n\nexport type RunFilterTokenType = 'id' | 'status' | 'pipeline' | 'job' | 'snapshotId' | 'tag';\n\nexport type RunFilterToken = {\n  token?: RunFilterTokenType;\n  value: string;\n};\n\nconst RUN_PROVIDERS_EMPTY = [\n  {\n    token: 'id',\n    values: () => [],\n  },\n  {\n    token: 'status',\n    values: () => [],\n  },\n  {\n    token: 'pipeline',\n    values: () => [],\n  },\n  {\n    token: 'job',\n    values: () => [],\n  },\n  {\n    token: 'tag',\n    values: () => [],\n  },\n  {\n    token: 'snapshotId',\n    values: () => [],\n  },\n];\n\n/**\n * This React hook provides run filtering state similar to React.useState(), but syncs\n * the value to the URL query string so that reloading the page / navigating \"back\"\n * maintains your view as expected.\n *\n * @param enabledFilters: This is useful if you want to ignore some filters that could\n * be provided (eg pipeline:, which is not relevant within pipeline scoped views.)\n */\nexport function useQueryPersistedRunFilters(enabledFilters?: RunFilterTokenType[]) {\n  return useQueryPersistedState<RunFilterToken[]>(\n    React.useMemo(\n      () => ({\n        encode: (tokens) => ({q: tokensAsStringArray(tokens), cursor: undefined}),\n        decode: ({q = []}) =>\n          tokenizedValuesFromStringArray(q, RUN_PROVIDERS_EMPTY).filter(\n            (t) =>\n              !t.token || !enabledFilters || enabledFilters.includes(t.token as RunFilterTokenType),\n          ) as RunFilterToken[],\n      }),\n      [enabledFilters],\n    ),\n  );\n}\n\nexport function runsPathWithFilters(filterTokens: RunFilterToken[]) {\n  return `/runs?${qs.stringify({q: tokensAsStringArray(filterTokens)}, {arrayFormat: 'brackets'})}`;\n}\n\nexport function runsFilterForSearchTokens(search: TokenizingFieldValue[]) {\n  if (!search[0]) {\n    return {};\n  }\n\n  const obj: RunsFilter = {};\n\n  for (const item of search) {\n    if (item.token === 'pipeline' || item.token === 'job') {\n      obj.pipelineName = item.value;\n    } else if (item.token === 'id') {\n      obj.runIds = obj.runIds || [];\n      obj.runIds.push(item.value);\n    } else if (item.token === 'status') {\n      obj.statuses = obj.statuses || [];\n      obj.statuses.push(item.value as RunStatus);\n    } else if (item.token === 'snapshotId') {\n      obj.snapshotId = item.value;\n    } else if (item.token === 'tag') {\n      const [key, value = ''] = item.value.split('=');\n      if (obj.tags) {\n        obj.tags.push({key, value});\n      } else {\n        obj.tags = [{key, value}];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction searchSuggestionsForRuns(\n  repositoryOptions: DagsterRepoOption[],\n  enabledFilters?: RunFilterTokenType[],\n): SuggestionProvider[] {\n  const pipelineNames = new Set<string>();\n  const jobNames = new Set<string>();\n\n  for (const option of repositoryOptions) {\n    const {repository} = option;\n    for (const pipeline of repository.pipelines) {\n      if (pipeline.isJob) {\n        jobNames.add(pipeline.name);\n      } else {\n        pipelineNames.add(pipeline.name);\n      }\n    }\n  }\n\n  const suggestions: {token: RunFilterTokenType; values: () => string[]}[] = [\n    {\n      token: 'id',\n      values: () => [],\n    },\n    {\n      token: 'status',\n      values: () => Object.keys(RunStatus),\n    },\n    {\n      token: 'pipeline',\n      values: () => Array.from(pipelineNames),\n    },\n    {\n      token: 'job',\n      values: () => Array.from(jobNames),\n    },\n    {\n      token: 'tag',\n      values: () => [],\n    },\n    {\n      token: 'snapshotId',\n      values: () => [],\n    },\n  ];\n\n  if (enabledFilters) {\n    return suggestions.filter((x) => enabledFilters.includes(x.token));\n  }\n\n  return suggestions;\n}\n\ninterface RunsFilterInputProps {\n  loading?: boolean;\n  tokens: RunFilterToken[];\n  onChange: (tokens: RunFilterToken[]) => void;\n  enabledFilters?: RunFilterTokenType[];\n}\n\nexport const RunsFilterInput: React.FC<RunsFilterInputProps> = ({\n  loading,\n  tokens,\n  onChange,\n  enabledFilters,\n}) => {\n  const {options} = useRepositoryOptions();\n\n  const suggestions = searchSuggestionsForRuns(options, enabledFilters);\n\n  const search = tokenizedValuesFromStringArray(tokensAsStringArray(tokens), suggestions);\n\n  const suggestionProvidersFilter = (\n    suggestionProviders: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => {\n    const tokens: string[] = [];\n    for (const {token} of values) {\n      if (token) {\n        tokens.push(token);\n      }\n    }\n\n    // If id is set, then no other filters can be set\n    if (tokens.includes('id')) {\n      return [];\n    }\n\n    // Can only have one filter value for pipeline or id\n    const limitedTokens = new Set<string>(['id', 'job', 'pipeline', 'snapshotId']);\n    const presentLimitedTokens = tokens.filter((token) => limitedTokens.has(token));\n\n    return suggestionProviders.filter(\n      (provider) => !provider.token || !presentLimitedTokens.includes(provider.token),\n    );\n  };\n\n  return (\n    <TokenizingField\n      values={search}\n      onChange={(values) => onChange(values as RunFilterToken[])}\n      suggestionProviders={suggestions}\n      suggestionProvidersFilter={suggestionProvidersFilter}\n      loading={loading}\n    />\n  );\n};\n","import * as React from 'react';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {IconName, Icon} from './Icon';\nimport {Spinner} from './Spinner';\nimport {Subheading} from './Text';\n\nexport type NonIdealStateProps = React.DetailedHTMLProps<\n  React.InputHTMLAttributes<HTMLInputElement>,\n  HTMLInputElement\n> & {\n  icon: 'error' | 'no-results' | 'spinner' | IconName;\n  title: string;\n  description?: React.ReactNode;\n  action?: React.ReactNode;\n  shrinkable?: boolean;\n};\n\nexport const NonIdealState: React.FC<NonIdealStateProps> = ({\n  title,\n  description,\n  icon,\n  action,\n  shrinkable,\n}) => {\n  const singleContentElement = [title, description, action].filter(Boolean).length === 1;\n\n  return (\n    <Box\n      flex={{gap: 20, alignItems: singleContentElement ? 'center' : 'flex-start'}}\n      background={Colors.Gray50}\n      padding={24}\n      style={{\n        margin: 'auto',\n        borderRadius: 8,\n        width: shrinkable ? 'initial' : 'max-content',\n        maxWidth: 500,\n      }}\n    >\n      {icon === 'spinner' ? (\n        <Spinner purpose=\"section\" />\n      ) : icon === 'no-results' ? (\n        <Icon name=\"search\" size={48} color={Colors.Gray400} />\n      ) : (\n        <Icon name={icon} size={48} color={Colors.Gray400} />\n      )}\n      <Box\n        flex={{\n          gap: 8,\n          direction: 'column',\n          alignItems: 'flex-start',\n        }}\n      >\n        {title && <Subheading style={{color: Colors.Gray900}}>{title}</Subheading>}\n        {description && <div style={{color: Colors.Gray500}}>{description}</div>}\n        {action}\n      </Box>\n    </Box>\n  );\n};\n","// eslint-disable-next-line no-restricted-imports\nimport {TagInput} from '@blueprintjs/core';\nimport * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {MenuItem, Menu} from './Menu';\nimport {Popover} from './Popover';\nimport {Spinner} from './Spinner';\n\nconst MAX_SUGGESTIONS = 100;\n\nexport interface SuggestionProvider {\n  token?: string;\n  values: () => string[];\n  suggestionFilter?: (query: string, suggestion: Suggestion) => boolean;\n}\n\nexport interface Suggestion {\n  text: string;\n  final: boolean;\n}\n\ninterface ActiveSuggestionInfo {\n  text: string;\n  idx: number;\n}\n\nexport interface TokenizingFieldValue {\n  token?: string;\n  value: string;\n}\n\ninterface TokenizingFieldProps {\n  values: TokenizingFieldValue[];\n  maxValues?: number;\n  onChange: (values: TokenizingFieldValue[]) => void;\n  onChangeBeforeCommit?: boolean;\n  addOnBlur?: boolean;\n  onFocus?: () => void;\n\n  placeholder?: string;\n  loading?: boolean;\n  className?: string;\n  small?: boolean;\n\n  fullwidth?: boolean;\n\n  suggestionProviders: SuggestionProvider[];\n  suggestionRenderer?: (suggestion: Suggestion) => React.ReactNode;\n  suggestionProvidersFilter?: (\n    suggestionProvider: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => SuggestionProvider[];\n}\n\nfunction findProviderByToken(token: string, providers: SuggestionProvider[]) {\n  return providers.find((p) => p.token && p.token.toLowerCase() === token.toLowerCase());\n}\n\nexport const tokenizedValuesFromString = (str: string, providers: SuggestionProvider[]) => {\n  if (str === '') {\n    return [];\n  }\n  const tokens = str.split(',');\n  return tokenizedValuesFromStringArray(tokens, providers);\n};\n\nexport const tokenizedValuesFromStringArray = (tokens: string[], providers: SuggestionProvider[]) =>\n  tokens.map((token) => tokenizedValueFromString(token, providers));\n\nexport const tokenizeString = (str: string): [string, string] => {\n  const colonAt = str.indexOf(':');\n  if (colonAt === -1) {\n    return [str, ''];\n  }\n  return [str.slice(0, colonAt), str.slice(colonAt + 1)];\n};\n\nexport function tokenizedValueFromString(\n  str: string,\n  providers: SuggestionProvider[],\n): TokenizingFieldValue {\n  const [token, value] = tokenizeString(str);\n  if (findProviderByToken(token, providers)) {\n    if (token && value) {\n      return {token, value};\n    }\n  }\n\n  return {value: str};\n}\n\nexport const tokenToString = (v: TokenizingFieldValue) =>\n  v.token ? `${v.token}:${v.value}` : v.value;\n\nexport const tokensAsStringArray = (value: TokenizingFieldValue[]) =>\n  value.filter((v) => v.value !== '').map(tokenToString);\n\nexport const stringFromValue = (value: TokenizingFieldValue[]) =>\n  tokensAsStringArray(value).join(',');\n\nconst isEqual = (a: TokenizingFieldValue, b?: TokenizingFieldValue) =>\n  b && a.token === b.token && a.value === b.value;\n\n/** Provides a text field with typeahead autocompletion.\n *  This completion either provides a list of standalone tokens\n *  sourced from the `tokens` param, or a set of key value pairs,\n *  sourced from the `suggestionProviders` param. In the latter case, the\n *  key is one of a known set of \"suggestion provider tokens\".\n *\n *  Provide one or more SuggestionProviders or a list of tokens\n *  to build the tree of autocompletions.\n *\n *  The input also allows for freeform typing (`value` items with no token value) */\nexport const TokenizingField: React.FC<TokenizingFieldProps> = ({\n  suggestionProviders,\n  suggestionProvidersFilter,\n  values: externalValues,\n  maxValues,\n  onChange,\n  onChangeBeforeCommit,\n  onFocus,\n  placeholder,\n  addOnBlur,\n  loading,\n  className,\n  fullwidth,\n  suggestionRenderer,\n}) => {\n  const [open, setOpen] = React.useState<boolean>(false);\n  const [active, setActive] = React.useState<ActiveSuggestionInfo | null>(null);\n  const [typed, setTyped] = React.useState<string>('');\n\n  const values = React.useMemo(() => [...externalValues], [externalValues]);\n  const typedValue = tokenizedValueFromString(typed, suggestionProviders);\n  if (isEqual(typedValue, values[values.length - 1])) {\n    values.pop();\n  }\n\n  const atMaxValues = maxValues !== undefined && values.length >= maxValues;\n\n  const filteredSuggestionProviders = suggestionProvidersFilter\n    ? suggestionProvidersFilter(suggestionProviders, values)\n    : suggestionProviders;\n\n  // Build the set of suggestions that should be displayed for the current input value.\n  // Note: \"typed\" is the text that has not yet been submitted, separate from values[].\n  const parts = typed.split(':');\n  const lastPart = (parts[parts.length - 1] || '').toLowerCase();\n\n  const suggestions = React.useMemo(() => {\n    if (atMaxValues) {\n      return [];\n    }\n\n    let suggestionsArr: Suggestion[] = [];\n\n    const matchesTypedText = (query: string, s: Suggestion) =>\n      !query ||\n      s.text\n        .toLowerCase()\n        .split(':')\n        .some((c) => c.includes(query));\n\n    const availableSuggestionsForProvider = (provider: SuggestionProvider) => {\n      const suggestionNotUsed = (v: string) =>\n        !values.some((e) => e.token === provider.token && e.value === v);\n\n      const suggestionFilter = provider.suggestionFilter || matchesTypedText;\n\n      return provider\n        .values()\n        .filter(suggestionNotUsed)\n        .map((v) => ({text: provider?.token ? `${provider.token}:${v}` : v, final: true}))\n        .filter((s) => suggestionFilter(lastPart, s))\n        .slice(0, MAX_SUGGESTIONS); // never show too many suggestions for one provider\n    };\n\n    if (parts.length === 1) {\n      // Suggest providers (eg: `pipeline:`) so users can discover the search space\n\n      suggestionsArr = filteredSuggestionProviders\n        .reduce(\n          (accum: Suggestion[], s) =>\n            s.token ? [...accum, {text: `${s.token}:`, final: false}] : accum,\n          [],\n        )\n        .filter((s) => matchesTypedText(lastPart, s));\n\n      // Suggest value completions so users can type \"airline_\" without the \"pipeline\"\n      // prefix and get the correct suggestion.\n      for (const p of filteredSuggestionProviders) {\n        if (!p.token || typed.length > 0) {\n          suggestionsArr.push(...availableSuggestionsForProvider(p));\n        }\n      }\n    }\n\n    if (parts.length === 2) {\n      const firstPart = parts[0];\n      if (firstPart) {\n        // Suggest values from the chosen provider (eg: `pipeline:abc`)\n        const provider = findProviderByToken(firstPart, filteredSuggestionProviders);\n        suggestionsArr = provider ? availableSuggestionsForProvider(provider) : [];\n      }\n    }\n\n    // Truncate suggestions to the ones currently matching the typed text,\n    // and always sort them in alphabetical order.\n    suggestionsArr.sort((a, b) => a.text.localeCompare(b.text));\n\n    return suggestionsArr;\n  }, [atMaxValues, filteredSuggestionProviders, lastPart, parts, typed.length, values]);\n\n  // We need to manage selection in the dropdown by ourselves. To ensure the\n  // best behavior we store the active item's index and text (the text allows\n  // us to relocate it if it's moved and the index allows us to keep selection\n  // at the same location if the previous item is gone.)\n\n  // This hook keeps the active row state in sync with the suggestions, which\n  // are derived from the current input value.\n\n  React.useEffect(() => {\n    // If suggestions are present, autoselect the first one so the user can press\n    // enter to complete their search. (Esc + enter is how you enter your raw text.)\n    if (!active && suggestions.length) {\n      const item = suggestions[0];\n      if (item) {\n        setActive({text: item.text, idx: 0});\n      }\n      return;\n    }\n    if (!active) {\n      return;\n    }\n    if (suggestions.length === 0) {\n      setActive(null);\n      return;\n    }\n\n    // Relocate the currently active item in the latest suggestions list\n    const pos = suggestions.findIndex((a) => a.text === active.text);\n\n    // The new index is the index of the active item, or whatever item\n    // is now at it's location if it's gone, bounded to the array.\n    let nextIdx = pos !== -1 ? pos : active.idx;\n    nextIdx = Math.max(0, Math.min(suggestions.length - 1, nextIdx));\n    const nextItem = suggestions[nextIdx];\n\n    if (nextItem && (nextIdx !== active.idx || nextItem.text !== active.text)) {\n      setActive({text: nextItem.text, idx: nextIdx});\n    }\n  }, [active, suggestions]);\n\n  const onConfirmSuggestion = (suggestion: Suggestion) => {\n    if (atMaxValues) {\n      return;\n    }\n\n    if (suggestion.final) {\n      // The user has finished a key-value pair\n      onConfirmText(suggestion.text);\n      setTyped('');\n      setActive(null);\n      setOpen(false);\n    } else {\n      // The user has finished a key\n      setTyped(suggestion.text);\n    }\n  };\n\n  const onConfirmText = (str: string) => {\n    if (atMaxValues) {\n      return;\n    }\n    if (str.endsWith(':')) {\n      return;\n    }\n    if (str === '') {\n      return;\n    }\n\n    setTyped('');\n    onChange([...values, tokenizedValueFromString(str, filteredSuggestionProviders)]);\n  };\n\n  const onKeyDown = (e: React.KeyboardEvent<any>) => {\n    if (atMaxValues && e.key !== 'Delete' && e.key !== 'Backspace') {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n    // Enter and Return confirm the currently selected suggestion or\n    // confirm the freeform text you've typed if no suggestions are shown.\n    if (e.key === 'Enter' || e.key === 'Return' || e.key === 'Tab') {\n      if (active) {\n        const picked = suggestions.find((s) => s.text === active.text);\n        if (!picked) {\n          throw new Error('Selection out of sync with suggestions');\n        }\n        onConfirmSuggestion(picked);\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (typed.length) {\n        onConfirmText(typed);\n        e.preventDefault();\n        e.stopPropagation();\n      }\n      return;\n    }\n\n    // Typing space confirms your freeform text\n    if (e.key === ' ') {\n      e.preventDefault();\n      onConfirmText(typed);\n      return;\n    }\n\n    // Escape closes the options. The options re-open if you type another char or click.\n    if (e.key === 'Escape') {\n      setActive(null);\n      setOpen(false);\n      return;\n    }\n\n    if (!open && e.key !== 'Delete' && e.key !== 'Backspace') {\n      setOpen(true);\n    }\n\n    // The up/down arrow keys shift selection in the dropdown.\n    // Note: The first down arrow press activates the first item.\n    const shift = {ArrowDown: 1, ArrowUp: -1}[e.key];\n    if (shift && suggestions.length > 0) {\n      e.preventDefault();\n      let idx = (active ? active.idx : -1) + shift;\n      idx = Math.max(0, Math.min(idx, suggestions.length - 1));\n      const item = suggestions[idx];\n      if (item) {\n        setActive({text: item.text, idx});\n      }\n    }\n  };\n\n  const menuRef = React.createRef<HTMLDivElement>();\n  React.useEffect(() => {\n    if (menuRef.current && active) {\n      const el = menuRef.current.querySelector(`[data-idx='${active.idx}']`);\n      if (el && el instanceof HTMLElement && 'scrollIntoView' in el) {\n        el.scrollIntoView({block: 'nearest'});\n      }\n    }\n  }, [menuRef, active]);\n\n  const renderSuggestion = suggestionRenderer || ((suggestion) => suggestion.text);\n\n  return (\n    <Popover\n      isOpen={open && suggestions.length > 0 && !atMaxValues}\n      position=\"bottom-left\"\n      content={\n        suggestions.length > 0 ? (\n          <div style={{maxHeight: 235, overflowY: 'scroll'}} ref={menuRef}>\n            <StyledMenu>\n              {suggestions.map((suggestion, idx) => (\n                <MenuItem\n                  data-idx={idx}\n                  key={suggestion.text}\n                  text={renderSuggestion(suggestion)}\n                  shouldDismissPopover={false}\n                  active={active?.idx === idx}\n                  onMouseDown={(e: React.MouseEvent<any>) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onConfirmSuggestion(suggestion);\n                    setActive(null);\n                  }}\n                />\n              ))}\n            </StyledMenu>\n          </div>\n        ) : (\n          <div />\n        )\n      }\n    >\n      <StyledTagInput\n        className={className}\n        values={values.map((v) => (v.token ? `${v.token}:${v.value}` : v.value))}\n        inputValue={typed}\n        onRemove={(_, idx) => {\n          const next = [...values];\n          next.splice(idx, 1);\n          onChange(next);\n        }}\n        onInputChange={(e) => {\n          setTyped(e.currentTarget.value);\n\n          if (onChangeBeforeCommit) {\n            const tokenized = tokenizedValueFromString(\n              e.currentTarget.value,\n              filteredSuggestionProviders,\n            );\n            onChange([...values, tokenized]);\n          }\n        }}\n        inputProps={{\n          onFocus: () => {\n            setOpen(true);\n            onFocus && onFocus();\n          },\n          onBlur: () => {\n            // Emulate behavior of addOnBlur for TagInput\n            // When a user clicks outside of the input, finish the current token\n            if (addOnBlur) {\n              onConfirmText(typed);\n            }\n            setOpen(false);\n          },\n        }}\n        $maxWidth={fullwidth ? '100%' : undefined}\n        onAdd={() => false}\n        onKeyDown={onKeyDown}\n        tagProps={{minimal: true}}\n        placeholder={placeholder || 'Filter…'}\n        rightElement={\n          loading && open ? (\n            <Box style={{alignSelf: 'center'}} margin={{right: 4}}>\n              <Spinner purpose=\"body-text\" />\n            </Box>\n          ) : undefined\n        }\n      />\n    </Popover>\n  );\n};\n\nexport const StyledTagInput = styled(TagInput)<{$maxWidth?: any}>`\n  border: none;\n  border-radius: 8px;\n  box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px;\n  min-width: 400px;\n  max-width: ${(p) => (p.$maxWidth ? p.$maxWidth : '600px')};\n  transition: box-shadow 150ms;\n\n  &.bp3-active {\n    box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px,\n      rgba(58, 151, 212, 0.6) 0 0 0 3px;\n  }\n\n  input {\n    font-size: 14px;\n    font-weight: 400;\n    padding-left: 4px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n  }\n\n  && .bp3-tag-input-values:first-child .bp3-input-ghost:first-child {\n    padding-left: 8px;\n  }\n\n  && .bp3-tag-input-values {\n    margin-right: 4px;\n    margin-top: 4px;\n  }\n\n  && .bp3-tag-input-values > * {\n    margin-bottom: 4px;\n  }\n\n  .bp3-tag {\n    border-radius: 6px;\n    display: inline-flex;\n    flex-direction: row;\n    font-size: 12px;\n    line-height: 16px;\n    align-items: center;\n    max-width: 400px;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    padding: 4px 8px;\n    user-select: none;\n  }\n\n  .bp3-tag.bp3-minimal:not([class*='bp3-intent-']) {\n    background-color: ${Colors.Gray100};\n    color: ${Colors.Gray900};\n  }\n\n  .bp3-tag.bp3-minimal.bp3-intent-success {\n    background-color: ${Colors.Green50};\n    color: ${Colors.Green700};\n  }\n\n  .bp3-tag.bp3-minimal.bp3-intent-warning {\n    background-color: ${Colors.Yellow50};\n    color: ${Colors.Yellow700};\n  }\n\n  .bp3-tag.bp3-minimal.bp3-intent-danger {\n    background-color: ${Colors.Red50};\n    color: ${Colors.Red700};\n  }\n`;\n\nconst StyledMenu = styled(Menu)`\n  width: 400px;\n`;\n"],"names":["useDocumentTitle","title","React","currentTitle","document","currentQueryString","useQueryPersistedState","options","queryKey","defaults","encode","decode","raw","qs","inferTypeOfQueryParam","location","useLocation","history","useHistory","search","ignoreQueryPrefix","qsWithDefaults","qsDecoded","result","Object","keys","key","inferTypeOfQueryParams","valueRef","onChangeRef","updated","next","entries","value","replace","pathname","arrayFormat","isEqual","current","q","PipelineReference","pipelineName","pipelineHrefContext","isJob","snapshotId","showIcon","truncationThreshold","size","truncatedName","length","slice","pipeline","to","workspacePipelinePathGuessRepo","workspacePipelinePath","repoName","name","repoLocation","flex","direction","alignItems","display","margin","right","color","Colors","queuedStatuses","Set","RunStatus","inProgressStatuses","successStatuses","failedStatuses","doneStatuses","cancelableStatuses","RUN_PROVIDERS_EMPTY","token","values","useQueryPersistedRunFilters","enabledFilters","tokens","tokensAsStringArray","cursor","undefined","tokenizedValuesFromStringArray","filter","t","includes","runsPathWithFilters","filterTokens","runsFilterForSearchTokens","obj","item","runIds","push","statuses","split","tags","RunsFilterInput","loading","onChange","suggestions","repositoryOptions","pipelineNames","jobNames","repository","pipelines","add","Array","from","x","searchSuggestionsForRuns","useRepositoryOptions","suggestionProviders","suggestionProvidersFilter","limitedTokens","presentLimitedTokens","has","provider","NonIdealState","description","icon","action","shrinkable","singleContentElement","Boolean","gap","background","padding","style","borderRadius","width","maxWidth","purpose","findProviderByToken","providers","find","p","toLowerCase","tokenizedValuesFromString","str","map","tokenizedValueFromString","colonAt","indexOf","tokenizeString","tokenToString","v","stringFromValue","join","TokenizingField","a","b","externalValues","maxValues","onChangeBeforeCommit","onFocus","placeholder","addOnBlur","className","fullwidth","suggestionRenderer","open","setOpen","active","setActive","typed","setTyped","typedValue","pop","atMaxValues","filteredSuggestionProviders","parts","lastPart","suggestionsArr","matchesTypedText","query","s","text","some","c","availableSuggestionsForProvider","suggestionFilter","e","final","reduce","accum","firstPart","sort","localeCompare","pos","findIndex","nextIdx","idx","Math","max","min","nextItem","onConfirmSuggestion","suggestion","onConfirmText","endsWith","menuRef","el","querySelector","HTMLElement","scrollIntoView","block","renderSuggestion","isOpen","position","content","maxHeight","overflowY","ref","StyledMenu","shouldDismissPopover","onMouseDown","preventDefault","stopPropagation","StyledTagInput","inputValue","onRemove","_","splice","onInputChange","currentTarget","tokenized","inputProps","onBlur","$maxWidth","onAdd","onKeyDown","shift","ArrowDown","ArrowUp","picked","Error","tagProps","minimal","rightElement","alignSelf","styled","TagInput","Menu"],"sourceRoot":""}